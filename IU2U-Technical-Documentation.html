
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>IU2U Technical Documentation</title>
            <style>
                @import url('https://fonts.googleapis.com/css2?family=Georgia:wght@400;700&display=swap');

                body {
                    font-family: 'Georgia', serif;
                    line-height: 1.7;
                    color: #2c3e50;
                    max-width: 820px;
                    margin: 0 auto;
                    padding: 30px;
                    background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
                    box-shadow: 0 0 20px rgba(0,0,0,0.1);
                }

                h1 {
                    color: #1a365d;
                    border-bottom: 4px solid #3182ce;
                    padding-bottom: 15px;
                    margin-top: 50px;
                    font-size: 2.2em;
                    font-weight: 700;
                    letter-spacing: -0.02em;
                    page-break-before: always;
                }

                h1:first-child {
                    page-break-before: auto;
                    margin-top: 0;
                }

                h2 {
                    color: #2d3748;
                    border-bottom: 3px solid #e2e8f0;
                    padding-bottom: 8px;
                    margin-top: 40px;
                    font-size: 1.6em;
                    font-weight: 600;
                }

                h3 {
                    color: #4a5568;
                    margin-top: 30px;
                    font-size: 1.3em;
                    font-weight: 600;
                }

                h4 {
                    color: #718096;
                    margin-top: 25px;
                    font-size: 1.1em;
                    font-weight: 500;
                }

                code {
                    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
                    padding: 3px 6px;
                    border-radius: 6px;
                    font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
                    font-size: 0.85em;
                    color: #e53e3e;
                }

                pre {
                    background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
                    border: none;
                    border-radius: 12px;
                    padding: 20px;
                    overflow-x: auto;
                    margin: 20px 0;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    position: relative;
                }
                
                pre code {
                    background: none;
                    padding: 0;
                    color: #e2e8f0;
                    font-size: 0.9em;
                }

                blockquote {
                    border-left: 5px solid #3182ce;
                    margin: 25px 0;
                    padding: 15px 20px;
                    background: linear-gradient(135deg, #ebf8ff 0%, #bee3f8 100%);
                    border-radius: 0 8px 8px 0;
                    color: #2c5282;
                    font-style: italic;
                    position: relative;
                }

                blockquote::before {
                    content: '"';
                    font-size: 4em;
                    color: #3182ce;
                    position: absolute;
                    top: -10px;
                    left: 10px;
                    opacity: 0.3;
                }

                table {
                    border-collapse: collapse;
                    width: 100%;
                    margin: 25px 0;
                    background: white;
                    border-radius: 8px;
                    overflow: hidden;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                }

                table th,
                table td {
                    border: 1px solid #e2e8f0;
                    padding: 12px 16px;
                    text-align: left;
                }

                table th {
                    background: linear-gradient(135deg, #3182ce 0%, #2c5282 100%);
                    color: white;
                    font-weight: 600;
                    text-transform: uppercase;
                    font-size: 0.85em;
                    letter-spacing: 0.5px;
                }

                table tbody tr:nth-child(even) {
                    background: #f8fafc;
                }

                table tbody tr:hover {
                    background: #edf2f7;
                }

                .page-break {
                    page-break-before: always;
                }

                .toc {
                    background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
                    border: 2px solid #e2e8f0;
                    border-radius: 12px;
                    padding: 30px;
                    margin: 30px 0;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                }

                .toc h2 {
                    margin-top: 0;
                    border-bottom: none;
                    color: #1a365d;
                    font-size: 1.8em;
                }

                .toc ul {
                    list-style-type: none;
                    padding-left: 0;
                }

                .toc li {
                    margin: 8px 0;
                    break-inside: avoid;
                }

                .toc a {
                    text-decoration: none;
                    color: #3182ce;
                    font-weight: 500;
                    transition: color 0.2s ease;
                }

                .toc a:hover {
                    color: #2c5282;
                }

                .cover-page {
                    text-align: center;
                    padding: 120px 40px;
                    display: flex;
                    flex-direction: column;
                    justify-content: start;
                    align-items: center;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    position: relative;
                    page-break-after: always;
                }

                .cover-page::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="white" opacity="0.1"/><circle cx="75" cy="75" r="1" fill="white" opacity="0.1"/><circle cx="50" cy="10" r="0.5" fill="white" opacity="0.05"/><circle cx="10" cy="50" r="0.5" fill="white" opacity="0.05"/><circle cx="90" cy="30" r="0.5" fill="white" opacity="0.05"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
                    pointer-events: none;
                }

                .cover-logo {
                    width: 120px;
                    height: 120px;
                    margin-bottom: 30px;
                    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
                }

                .cover-org {
                    font-size: 1.2em;
                    color: rgba(255,255,255,0.9);
                    margin-bottom: 20px;
                    font-weight: 400;
                    letter-spacing: 2px;
                    text-transform: uppercase;
                }

                .cover-title {
                    font-size: 3.5em;
                    font-weight: 700;
                    margin-bottom: 15px;
                    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    letter-spacing: -0.02em;
                }

                .cover-subtitle {
                    font-size: 1.4em;
                    color: rgba(255,255,255,0.9);
                    margin-bottom: 40px;
                    font-weight: 300;
                    max-width: 600px;
                    line-height: 1.4;
                }

                .cover-features {
                    display: flex;
                    gap: 30px;
                    margin-bottom: 40px;
                    flex-wrap: wrap;
                    justify-content: center;
                }

                .cover-feature {
                    background: rgba(255,255,255,0.1);
                    padding: 15px 20px;
                    border-radius: 25px;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255,255,255,0.2);
                    font-size: 0.9em;
                    font-weight: 500;
                }

                .cover-info {
                    font-size: 1em;
                    color: rgba(255,255,255,0.8);
                    line-height: 1.8;
                    font-weight: 300;
                }

                @media print {
                    body {
                        margin: 0;
                        padding: 20px;
                        background: white !important;
                        box-shadow: none !important;
                    }

                    h1 {
                        page-break-before: always;
                        color: #1a365d !important;
                    }

                    h1:first-child {
                        page-break-before: auto;
                    }

                    pre {
                        page-break-inside: avoid;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
                    }

                    table {
                        page-break-inside: avoid;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
                    }

                    .cover-page {
                        background: #667eea !important;
                        -webkit-print-color-adjust: exact;
                        color-adjust: exact;
                    }
                }
            </style>
        </head>
        <body>
        
        <div class="cover-page">
            <div class="cover-title">IU2U Protocol</div>
            <div class="cover-subtitle">Complete Cross-Chain & Gasless Solution<br>Technical Documentation</div>
            <div class="cover-features">
                <div class="cover-feature">Gasless Meta Transactions</div>
                <div class="cover-feature">IU2U Cross-Chain Bridge</div>
                <div class="cover-feature">DEX Aggregation (37+ Protocols)</div>
            </div>            
            <div class="cover-info">
                Version 1.0 | 9/26/2025<br>
            </div>
            <img src="docs/logo.png" alt="DI Networks Logo" class="cover-logo" onerror="this.style.display='none'">
            <div class="cover-org">DI Networks</div>
        </div>
        
        <div class="toc">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#iu2u-protocol-overview">IU2U Protocol Overview</a></li>
                <li><a href="#protocol-architecture">Protocol Architecture</a></li>
                <li><a href="#iu2u-token">IU2U Token</a></li>
                <li><a href="#gasless-meta-transactions">Gasless Meta Transactions</a></li>
                <li><a href="#cross-chain-bridge">Cross-Chain Bridge</a></li>
                <li><a href="#dex-aggregation">DEX Aggregation</a></li>
                <li><a href="#metatx-gateway">MetaTx Gateway</a></li>
                <li><a href="#gas-credit-vault">Gas Credit Vault</a></li>
                <li><a href="#token-transfers">Token Transfers</a></li>
                <li><a href="#supported-dex-protocols">Supported DEX Protocols</a></li>
                <li><a href="#relayer-network">Relayer Network</a></li>
                <li><a href="#security-model">Security Model</a></li>
                <li><a href="#api-reference">API Reference</a></li>
                <li><a href="#quick-start-guide">Quick Start Guide</a></li>
                <li><a href="#installation">Installation</a></li>
                <li><a href="#integration-guide">Integration Guide</a></li>
            </ul>
        </div>
        <div class="page-break"></div><h1 id="iu2u-protocol-overview">IU2U Protocol Overview</h1><p><img src="IU2U-Banner.png" alt="IU2U Protocol"></p>
<p>Welcome to the comprehensive documentation for the IU2U Protocol - a revolutionary cross-chain infrastructure that enables seamless token swaps, cross-chain communication across multiple blockchain networks.</p>
<h2>What is IU2U?</h2>
<p>IU2U is a cross-chain protocol that facilitates:</p>
<ul>
<li><strong>Cross-Chain Token Transfers</strong>: Send tokens between different blockchain networks</li>
<li><strong>DEX Aggregation</strong>: Access 37+ DEX protocols across 7 chains for optimal swap routing</li>
<li><strong>General Message Passing</strong>: Send arbitrary data and function calls across chains</li>
</ul>
<h2>Quick Start</h2>
<p>{% content-ref url=&quot;getting-started/installation.md&quot; %}
<a href="getting-started/installation.md">installation.md</a>
{% endcontent-ref %}</p>
<p>{% content-ref url=&quot;getting-started/quick-start.md&quot; %}
<a href="getting-started/quick-start.md">quick-start.md</a>
{% endcontent-ref %}</p>
<h2>Core Features</h2>
<h3>üîó Cross-Chain Infrastructure</h3>
<ul>
<li>Supports 7 major blockchain networks</li>
<li>1:1 U2U backing mechanism</li>
<li>Decentralized relayer network</li>
</ul>
<h3>üîÑ DEX Aggregation</h3>
<ul>
<li>37+ supported DEX protocols</li>
<li>Optimal routing algorithms</li>
<li>Multi-protocol quote comparison</li>
<li>V2 and V3 concentrated liquidity support</li>
</ul>
<h3>üõ°Ô∏è Security &amp; Reliability</h3>
<ul>
<li>Comprehensive audit coverage</li>
<li>Decentralized architecture</li>
<li>Emergency recovery mechanisms</li>
</ul>
<h2>Supported Networks</h2>
<table>
<thead>
<tr>
<th>Network</th>
<th>Chain ID</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td>Ethereum</td>
<td>1</td>
<td>‚úÖ Live</td>
</tr>
<tr>
<td>BSC</td>
<td>56</td>
<td>‚úÖ Live</td>
</tr>
<tr>
<td>Polygon</td>
<td>137</td>
<td>‚úÖ Live</td>
</tr>
<tr>
<td>Avalanche</td>
<td>43114</td>
<td>‚úÖ Live</td>
</tr>
<tr>
<td>Arbitrum</td>
<td>42161</td>
<td>‚úÖ Live</td>
</tr>
<tr>
<td>Optimism</td>
<td>10</td>
<td>‚úÖ Live</td>
</tr>
<tr>
<td>Base</td>
<td>8453</td>
<td>‚úÖ Live</td>
</tr>
</tbody></table>
<h2>Architecture Overview</h2>
<pre><code class="language-mermaid">flowchart TB
    A[User] --&gt; B[IU2U Gateway]
    B --&gt; C[Cross-Chain Aggregator]
    C --&gt; E[37 DEX Protocols]
    B --&gt; F[Relayer Network]
    F --&gt; G[Destination Chain]
    G --&gt; H[IU2U Gateway]
    H --&gt; I[Target Contract]
</code></pre>
<h2>Getting Help</h2>
<ul>
<li>üìñ Browse the documentation sections</li>
<li>üí¨ Join our <a href="https://discord.gg/u2u">Discord community</a></li>
<li>üêõ Report issues on <a href="https://github.com/U2U-Network/U2U-Contracts">GitHub</a></li>
<li>üìß Contact support: <a href="mailto:support@iu2u.com">support@iu2u.com</a></li>
</ul>
<h2>Documentation Structure</h2>
<p>This documentation is organized into the following sections:</p>
<ul>
<li><strong>Getting Started</strong>: Installation, setup, and basic usage</li>
<li><strong>Core Concepts</strong>: Understanding IU2U&#39;s architecture and mechanisms</li>
<li><strong>DEX Aggregation</strong>: Multi-protocol trading and routing</li>
<li><strong>Cross-Chain</strong>: Bridge operations and message passing</li>
<li><strong>API Reference</strong>: Complete function and event documentation</li>
<li><strong>Guides</strong>: Step-by-step tutorials and best practices</li>
<li><strong>Examples</strong>: Real-world integration patterns</li>
</ul>
<hr>
<p><em>Ready to build with IU2U? Start with our <a href="getting-started/quick-start.md">Quick Start Guide</a>!</em></p>
<div class="page-break"></div><h1 id="protocol-architecture">Protocol Architecture</h1><p>IU2U Protocol is a comprehensive cross-chain infrastructure that enables seamless token transfers, DEX aggregation, and gasless transactions across multiple blockchain networks.</p>
<h2>Core Architecture</h2>
<pre><code class="language-mermaid">flowchart TB
    subgraph &quot;User Layer&quot;
        U[User/DApp]
        W[Web3 Wallet]
    end
    
    subgraph &quot;IU2U Protocol&quot;
        G[IU2U Gateway]
        A[CrossChain Aggregator]
        R[Relayer Network]
    end
    
    subgraph &quot;DEX Layer&quot;
        UV2[Uniswap V2]
        UV3[Uniswap V3]
        S[SushiSwap]
        C[Curve]
        B[Balancer]
        O[Others...]
    end
    
    subgraph &quot;Blockchain Networks&quot;
        ETH[Ethereum]
        BSC[BSC]
        POLY[Polygon]
        AVAX[Avalanche]
        ARB[Arbitrum]
        OP[Optimism]
        BASE[Base]
    end
    
    U --&gt; W
    W --&gt; G
    G --&gt; A
    A --&gt; UV2
    A --&gt; UV3
    A --&gt; S
    A --&gt; C
    A --&gt; B
    A --&gt; O
    G --&gt; R
    R --&gt; ETH
    R --&gt; BSC
    R --&gt; POLY
    R --&gt; AVAX
    R --&gt; ARB
    R --&gt; OP
    R --&gt; BASE
</code></pre>
<h2>Key Components</h2>
<h3>1. IU2U Gateway</h3>
<p>The central hub for all cross-chain operations:</p>
<ul>
<li><strong>U2U ‚Üî IU2U Conversion</strong>: 1:1 backing mechanism on U2U chain</li>
<li><strong>Message Passing</strong>: Cross-chain communication protocol</li>
<li><strong>Token Bridging</strong>: Secure token transfers between chains</li>
<li><strong>Relayer Management</strong>: Coordination of decentralized relayers</li>
</ul>
<p><strong>Key Features:</strong></p>
<ul>
<li>‚úÖ Fully collateralized backing</li>
<li>‚úÖ Decentralized validation</li>
<li>‚úÖ Emergency pause mechanisms</li>
<li>‚úÖ Upgrade governance</li>
</ul>
<h3>2. CrossChain Aggregator</h3>
<p>Advanced DEX aggregation system supporting 37+ protocols:</p>
<ul>
<li><strong>Multi-Protocol Routing</strong>: Optimal path finding across DEXes</li>
<li><strong>Price Discovery</strong>: Real-time quote comparison</li>
<li><strong>Cross-Chain Swaps</strong>: A‚ÜíIU2U‚ÜíB token swaps across chains</li>
<li><strong>Slippage Protection</strong>: Automated price impact management</li>
</ul>
<p><strong>Supported Protocols:</strong></p>
<ul>
<li><strong>V2 AMMs</strong>: Uniswap V2, SushiSwap V2, PancakeSwap V2, QuickSwap</li>
<li><strong>V3 Concentrated Liquidity</strong>: Uniswap V3, SushiSwap V3, PancakeSwap V3</li>
<li><strong>Stableswap</strong>: Curve Finance, Ellipsis Finance</li>
<li><strong>Weighted Pools</strong>: Balancer V2</li>
<li><strong>Solidly Forks</strong>: Velodrome, Aerodrome, Thena</li>
</ul>
<h3>3. Meta-Transaction System</h3>
<p>Gasless transaction execution infrastructure:</p>
<ul>
<li><strong>Gas Credit Vault</strong>: IU2U-based gas payment system</li>
<li><strong>Signature Validation</strong>: EIP-712 meta-transaction support</li>
<li><strong>Relayer Coordination</strong>: Distributed transaction execution</li>
<li><strong>Cost Optimization</strong>: Dynamic gas price management</li>
</ul>
<h3>4. Relayer Network</h3>
<p>Decentralized infrastructure for cross-chain operations:</p>
<ul>
<li><strong>Whitelisted Relayers</strong>: Vetted operator network</li>
<li><strong>Consensus Mechanism</strong>: Multi-signature validation</li>
<li><strong>Monitoring &amp; Alerts</strong>: Real-time system health tracking</li>
<li><strong>Incentive Alignment</strong>: Fee-based compensation model</li>
</ul>
<h2>Protocol Flow</h2>
<h3>Standard Cross-Chain Swap</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Gateway_A as Gateway (Chain A)
    participant Relayer
    participant Gateway_B as Gateway (Chain B)
    participant DEX
    
    User-&gt;&gt;Gateway_A: Initiate swap (Token A ‚Üí IU2U)
    Gateway_A-&gt;&gt;Gateway_A: Execute local swap
    Gateway_A-&gt;&gt;Relayer: Send cross-chain message
    Relayer-&gt;&gt;Gateway_B: Relay message + IU2U
    Gateway_B-&gt;&gt;DEX: Execute swap (IU2U ‚Üí Token B)
    Gateway_B-&gt;&gt;User: Send Token B
    Gateway_B-&gt;&gt;Relayer: Confirm completion
    Relayer-&gt;&gt;Gateway_A: Update status
    
</code></pre>
<h3>Meta-Transaction Flow</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Frontend
    participant Relayer
    participant MetaTx Gateway
    participant Target Contract
    
    User-&gt;&gt;Frontend: Sign meta-transaction
    Frontend-&gt;&gt;Relayer: Submit signed transaction
    Relayer-&gt;&gt;Relayer: Validate signature &amp; gas credits
    Relayer-&gt;&gt;MetaTx Gateway: Execute transaction
    MetaTx Gateway-&gt;&gt;Target Contract: Forward call
    Target Contract-&gt;&gt;MetaTx Gateway: Return result
    MetaTx Gateway-&gt;&gt;Relayer: Emit events
    Relayer-&gt;&gt;Frontend: Return receipt
</code></pre>
<h2>Security Model</h2>
<h3>Multi-Layer Security</h3>
<ol>
<li><p><strong>Smart Contract Security</strong></p>
<ul>
<li>Formal verification for critical functions</li>
<li>Multiple audit rounds</li>
<li>Bug bounty programs</li>
<li>Gradual deployment strategy</li>
</ul>
</li>
<li><p><strong>Operational Security</strong></p>
<ul>
<li>Multi-signature governance</li>
<li>Time-locked upgrades</li>
<li>Emergency pause mechanisms</li>
<li>Relayer reputation system</li>
</ul>
</li>
<li><p><strong>Economic Security</strong></p>
<ul>
<li>Full collateralization (1:1 U2U backing)</li>
<li>Slashing conditions for malicious relayers</li>
<li>Insurance fund for exceptional cases</li>
<li>Progressive decentralization model</li>
</ul>
</li>
</ol>
<h3>Risk Mitigation</h3>
<p><strong>Smart Contract Risks:</strong></p>
<ul>
<li>‚úÖ Comprehensive testing suites</li>
<li>‚úÖ Formal verification</li>
<li>‚úÖ Multiple security audits</li>
<li>‚úÖ Bug bounty programs</li>
</ul>
<p><strong>Bridge Risks:</strong></p>
<ul>
<li>‚úÖ Over-collateralization</li>
<li>‚úÖ Decentralized validation</li>
<li>‚úÖ Emergency pause mechanisms</li>
<li>‚úÖ Fraud proof systems</li>
</ul>
<p><strong>Economic Risks:</strong></p>
<ul>
<li>‚úÖ Insurance mechanisms</li>
<li>‚úÖ Diversified relayer set</li>
<li>‚úÖ Dynamic fee adjustments</li>
<li>‚úÖ Circuit breakers</li>
</ul>
<h2>Token Economics</h2>
<h3>IU2U Token</h3>
<p><strong>Supply Mechanism:</strong></p>
<ul>
<li>IU2U tokens are minted 1:1 when U2U is deposited on U2U</li>
<li>IU2U tokens are burned 1:1 when U2U is withdrawn on U2U</li>
<li>No inflation or pre-mining</li>
<li>Fully backed by native U2U reserves</li>
</ul>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Cross-chain value transfer</li>
<li>Gas payment for meta-transactions</li>
<li>DEX trading and liquidity provision</li>
<li>Governance participation (future)</li>
</ul>
<p><strong>Cross-Chain Presence:</strong></p>
<ul>
<li>Native on U2U (convertible to/from U2U)</li>
<li>Bridged on Ethereum, BSC, Polygon, Avalanche, Arbitrum, Optimism, Base</li>
<li>Maintains same total supply across all chains</li>
</ul>
<h3>Fee Structure</h3>
<p><strong>Cross-Chain Operations:</strong></p>
<ul>
<li>Bridge fee: 0.1% of transferred amount</li>
<li>Relayer fee: Dynamic based on gas costs</li>
<li>Protocol fee: 0.05% to treasury</li>
</ul>
<p><strong>DEX Aggregation:</strong></p>
<ul>
<li>Routing fee: 0.05% on optimal path</li>
<li>Gas optimization savings shared with users</li>
<li>No additional fees for quote comparisons</li>
</ul>
<p><strong>Meta-Transactions:</strong></p>
<ul>
<li>Gas cost + 10% relayer premium</li>
<li>Paid in IU2U tokens</li>
<li>Dynamic pricing based on network congestion</li>
</ul>
<h2>Governance</h2>
<h3>Progressive Decentralization</h3>
<p><strong>Phase 1: Foundation Control</strong> (Current)</p>
<ul>
<li>Core team manages upgrades</li>
<li>Emergency pause capabilities</li>
<li>Relayer whitelisting authority</li>
</ul>
<p><strong>Phase 2: Community Governance</strong> (Planned)</p>
<ul>
<li>Token-based voting system</li>
<li>Proposal and execution delays</li>
<li>Community treasury management</li>
</ul>
<p><strong>Phase 3: Full Decentralization</strong> (Future)</p>
<ul>
<li>On-chain governance for all parameters</li>
<li>Automatic execution of proposals</li>
<li>Minimal foundation involvement</li>
</ul>
<h3>Governance Parameters</h3>
<p><strong>Adjustable Parameters:</strong></p>
<ul>
<li>Cross-chain fees</li>
<li>Slippage tolerances</li>
<li>Relayer requirements</li>
<li>Emergency thresholds</li>
<li>Protocol upgrades</li>
</ul>
<h2>Network Support</h2>
<h3>Supported Chains</h3>
<table>
<thead>
<tr>
<th>Network</th>
<th>Chain ID</th>
<th>Status</th>
<th>Features</th>
</tr>
</thead>
<tbody><tr>
<td>U2U Nebulas Testnet</td>
<td>2484</td>
<td>‚úÖ Native</td>
<td>U2U ‚Üî IU2U conversion</td>
</tr>
<tr>
<td>Ethereum</td>
<td>1</td>
<td>‚úÖ Live</td>
<td>Full DEX aggregation</td>
</tr>
<tr>
<td>BSC</td>
<td>56</td>
<td>‚úÖ Live</td>
<td>PancakeSwap ecosystem</td>
</tr>
<tr>
<td>Polygon</td>
<td>137</td>
<td>‚úÖ Live</td>
<td>Low-cost operations</td>
</tr>
<tr>
<td>Avalanche</td>
<td>43114</td>
<td>‚úÖ Live</td>
<td>TraderJoe integration</td>
</tr>
<tr>
<td>Arbitrum</td>
<td>42161</td>
<td>‚úÖ Live</td>
<td>L2 efficiency</td>
</tr>
<tr>
<td>Optimism</td>
<td>10</td>
<td>‚úÖ Live</td>
<td>Velodrome support</td>
</tr>
<tr>
<td>Base</td>
<td>8453</td>
<td>‚úÖ Live</td>
<td>Coinbase L2</td>
</tr>
</tbody></table>
<h3>Future Expansions</h3>
<p><strong>Planned Integrations:</strong></p>
<ul>
<li>Solana (via Wormhole)</li>
<li>Cosmos ecosystem</li>
<li>Polkadot parachains</li>
<li>Additional EVM chains</li>
</ul>
<h2>Performance Metrics</h2>
<h3>Transaction Throughput</h3>
<ul>
<li><strong>Same-chain swaps</strong>: Sub-second execution</li>
<li><strong>Cross-chain transfers</strong>: 2-5 minutes average</li>
<li><strong>Meta-transactions</strong>: 1-2 block confirmations</li>
<li><strong>Quote aggregation</strong>: &lt;500ms response time</li>
</ul>
<h3>Cost Efficiency</h3>
<ul>
<li><strong>Gas optimization</strong>: 15-30% savings vs. direct DEX interaction</li>
<li><strong>Cross-chain costs</strong>: 60-80% lower than traditional bridges</li>
<li><strong>Meta-transaction costs</strong>: Market rate + 10% relayer premium</li>
</ul>
<h3>Reliability</h3>
<ul>
<li><strong>Uptime</strong>: 99.9% target</li>
<li><strong>Success rate</strong>: &gt;99% for standard operations</li>
<li><strong>Recovery time</strong>: &lt;1 hour for emergency situations</li>
</ul>
<h2>Integration Benefits</h2>
<h3>For Users</h3>
<ul>
<li>‚úÖ Best prices across all DEXes</li>
<li>‚úÖ Gasless transaction option</li>
<li>‚úÖ Seamless cross-chain experience</li>
<li>‚úÖ Single interface for multiple chains</li>
</ul>
<h3>For Developers</h3>
<ul>
<li>‚úÖ Simple SDK integration</li>
<li>‚úÖ Comprehensive API coverage</li>
<li>‚úÖ Extensive documentation</li>
<li>‚úÖ Active developer support</li>
</ul>
<h3>For DApps</h3>
<ul>
<li>‚úÖ Enhanced user experience</li>
<li>‚úÖ Multi-chain accessibility</li>
<li>‚úÖ Reduced integration complexity</li>
<li>‚úÖ Built-in MEV protection</li>
</ul>
<h2>Next Steps</h2>
<p>To dive deeper into IU2U Protocol:</p>
<ol>
<li><strong><a href="iu2u-token.md">Learn about IU2U Token</a></strong> - Understand tokenomics</li>
<li><strong><a href="cross-chain-architecture.md">Explore Cross-Chain Architecture</a></strong> - Technical deep dive</li>
<li><strong><a href="relayer-network.md">Study the Relayer Network</a></strong> - Decentralized infrastructure</li>
<li><strong><a href="security-model.md">Review Security Model</a></strong> - Risk assessment and mitigation</li>
</ol>
<p>Ready to start building? Check out our <a href="../getting-started/quick-start.md">Quick Start Guide</a>!</p>
<div class="page-break"></div><h1 id="iu2u-token">IU2U Token</h1><p>The IU2U token is the native cross-chain token of the IU2U Protocol, designed to facilitate seamless value transfer and serve as a medium of exchange across multiple blockchain networks.</p>
<h2>Token Overview</h2>
<p>IU2U tokens are 1:1 backed by U2U (U2U Chain&#39;s native token) and serve as the protocol&#39;s native asset for:</p>
<ul>
<li>Cross-chain token transfers</li>
<li>DEX aggregation operations  </li>
<li>Gas fee payments in gasless transactions</li>
<li>Protocol governance and staking</li>
</ul>
<h2>Technical Specifications</h2>
<h3>Contract Details</h3>
<pre><code class="language-solidity">// Token Information
Name: IU2U Token
Symbol: IU2U
Decimals: 18
Total Supply: Dynamic (minted/burned based on bridging)
Standard: ERC20 with cross-chain extensions
</code></pre>
<h3>Key Features</h3>
<ol>
<li><strong>Cross-Chain Native</strong>: Deployed on multiple chains with unified balances</li>
<li><strong>Burnable/Mintable</strong>: Supports cross-chain operations through burn/mint mechanisms</li>
<li><strong>Gasless Support</strong>: Integrated with meta-transaction capabilities</li>
<li><strong>Multi-signature Security</strong>: Relayer network validation for cross-chain operations</li>
</ol>
<h2>Token Economics</h2>
<h3>Supply Mechanism</h3>
<pre><code class="language-mermaid">flowchart LR
    A[U2U Deposit] --&gt; B[IU2U Mint]
    B --&gt; C[Cross-Chain Transfer]
    C --&gt; D[IU2U Burn]
    D --&gt; E[U2U Release]
    
</code></pre>
<ol>
<li><strong>Minting</strong>: IU2U tokens are minted when U2U is deposited into the protocol</li>
<li><strong>Burning</strong>: IU2U tokens are burned when withdrawing to U2U</li>
<li><strong>Cross-Chain</strong>: Tokens are burned on source chain and minted on destination chain</li>
</ol>
<h3>Backing Mechanism</h3>
<ul>
<li><strong>1:1 U2U Backing</strong>: Every IU2U token is backed by 1 U2U token</li>
<li><strong>Reserve Verification</strong>: Smart contracts ensure proper backing at all times</li>
<li><strong>Audit Trail</strong>: All mint/burn operations are transparently recorded on-chain</li>
</ul>
<h2>Cross-Chain Operations</h2>
<h3>Bridge Mechanism</h3>
<p>The IU2U token uses a sophisticated bridge mechanism:</p>
<ol>
<li><strong>Lock &amp; Mint</strong>: On non-native chains, U2U is locked and IU2U is minted</li>
<li><strong>Burn &amp; Release</strong>: When bridging back, IU2U is burned and U2U is released</li>
<li><strong>Relayer Validation</strong>: Multi-signature relayer network validates all operations</li>
</ol>
<h3>Supported Chains</h3>
<table>
<thead>
<tr>
<th>Chain</th>
<th>Network ID</th>
<th>IU2U Address</th>
<th>Status</th>
</tr>
</thead>
<tbody><tr>
<td>U2U Nebulas Testnet</td>
<td>2484</td>
<td><code>0x...</code></td>
<td>Native</td>
</tr>
<tr>
<td>Ethereum</td>
<td>1</td>
<td><code>0x...</code></td>
<td>Deployed</td>
</tr>
<tr>
<td>BSC</td>
<td>56</td>
<td><code>0x...</code></td>
<td>Deployed</td>
</tr>
<tr>
<td>Polygon</td>
<td>137</td>
<td><code>0x...</code></td>
<td>Deployed</td>
</tr>
<tr>
<td>Arbitrum</td>
<td>42161</td>
<td><code>0x...</code></td>
<td>Deployed</td>
</tr>
<tr>
<td>Optimism</td>
<td>10</td>
<td><code>0x...</code></td>
<td>Deployed</td>
</tr>
<tr>
<td>Avalanche</td>
<td>43114</td>
<td><code>0x...</code></td>
<td>Deployed</td>
</tr>
</tbody></table>
<h2>Smart Contract Architecture</h2>
<h3>Core Functions</h3>
<pre><code class="language-solidity">// Minting (Cross-chain transfers in)
function mint(address to, uint256 amount) external onlyRelayer

// Burning (Cross-chain transfers out)
function burn(uint256 amount) external

// Cross-chain call with token transfer
function callContractWithToken(
    string memory destinationChain,
    string memory contractAddress,
    bytes memory payload,
    string memory symbol,
    uint256 amount
) external
</code></pre>
<h3>Security Features</h3>
<ol>
<li><strong>Multi-signature Relayers</strong>: Requires multiple relayer signatures for operations</li>
<li><strong>Command Validation</strong>: All cross-chain commands are cryptographically verified</li>
<li><strong>Replay Protection</strong>: Prevents duplicate transaction execution</li>
<li><strong>Rate Limiting</strong>: Configurable limits on large transfers</li>
</ol>
<h2>Integration Guide</h2>
<h3>For DApp Developers</h3>
<pre><code class="language-javascript">// Get IU2U token contract
const iu2u = new ethers.Contract(IU2U_ADDRESS, IU2U_ABI, signer);

// Transfer tokens cross-chain
await iu2u.callContractWithToken(
    &quot;ethereum&quot;,           // destination chain
    &quot;0x...&quot;,             // destination contract
    &quot;0x...&quot;,             // payload
    &quot;IU2U&quot;,              // token symbol
    ethers.parseEther(&quot;100&quot;) // amount
);
</code></pre>
<h3>For DEX Integration</h3>
<pre><code class="language-javascript">// Check IU2U balance
const balance = await iu2u.balanceOf(userAddress);

// Approve for DEX trading
await iu2u.approve(dexAddress, amount);

// Use in DEX aggregation
await aggregator.swapExactTokensForTokens(
    amountIn,
    amountOutMin,
    [IU2U_ADDRESS, tokenOut],
    recipient,
    deadline
);
</code></pre>
<h2>Use Cases</h2>
<h3>1. Cross-Chain Arbitrage</h3>
<p>Traders can use IU2U to:</p>
<ul>
<li>Identify price differences across chains</li>
<li>Transfer funds quickly between DEXes</li>
<li>Execute arbitrage strategies with minimal slippage</li>
</ul>
<h3>2. Multi-Chain DeFi</h3>
<p>DeFi protocols can integrate IU2U to:</p>
<ul>
<li>Accept deposits from any supported chain</li>
<li>Provide unified liquidity across chains</li>
<li>Enable cross-chain yield farming</li>
</ul>
<h3>3. Payment Infrastructure</h3>
<p>Merchants can use IU2U for:</p>
<ul>
<li>Cross-border payments</li>
<li>Multi-chain invoicing</li>
<li>Gasless transactions for users</li>
</ul>
<h2>Security Considerations</h2>
<h3>Risk Factors</h3>
<ol>
<li><strong>Bridge Security</strong>: Cross-chain operations depend on relayer network security</li>
<li><strong>Smart Contract Risk</strong>: Standard smart contract vulnerabilities apply</li>
<li><strong>Chain-Specific Risks</strong>: Each blockchain has inherent risks</li>
</ol>
<h3>Mitigation Strategies</h3>
<ol>
<li><strong>Multi-signature Validation</strong>: No single point of failure in relayer network</li>
<li><strong>Formal Verification</strong>: Core contracts undergo formal verification</li>
<li><strong>Bug Bounty Program</strong>: Active security researcher engagement</li>
<li><strong>Regular Audits</strong>: Quarterly security audits by leading firms</li>
</ol>
<h2>Governance</h2>
<h3>Token Voting Rights</h3>
<p>IU2U holders can participate in:</p>
<ul>
<li>Protocol parameter updates</li>
<li>New chain integrations</li>
<li>Relayer network changes</li>
<li>Fee structure modifications</li>
</ul>
<h3>Proposal Process</h3>
<ol>
<li><strong>Proposal Submission</strong>: Community members submit proposals</li>
<li><strong>Discussion Period</strong>: 7-day community discussion</li>
<li><strong>Voting Period</strong>: 3-day token holder voting</li>
<li><strong>Implementation</strong>: Successful proposals are implemented</li>
</ol>
<h2>Roadmap</h2>
<h3>Short Term (Q1-Q2 2025)</h3>
<ul>
<li><input disabled="" type="checkbox"> Additional DEX integrations</li>
<li><input disabled="" type="checkbox"> Mobile wallet support</li>
<li><input disabled="" type="checkbox"> Gas optimization improvements</li>
</ul>
<h3>Medium Term (Q3-Q4 2025)</h3>
<ul>
<li><input disabled="" type="checkbox"> Layer 2 expansion</li>
<li><input disabled="" type="checkbox"> Institutional custody support  </li>
<li><input disabled="" type="checkbox"> Advanced trading features</li>
</ul>
<h3>Long Term (2026+)</h3>
<ul>
<li><input disabled="" type="checkbox"> Non-EVM chain support</li>
<li><input disabled="" type="checkbox"> Native staking mechanisms</li>
<li><input disabled="" type="checkbox"> Advanced governance features</li>
</ul>
<h2>Resources</h2>
<ul>
<li><a href="../api-reference/iu2u-gateway.md">Token Contract</a></li>
<li><a href="../cross-chain/token-transfers.md">Cross-Chain Guide</a></li>
<li><a href="../examples/basic-swap.md">Integration Examples</a></li>
<li><a href="../guides/security.md">Security Best Practices</a></li>
</ul>
<div class="page-break"></div><h1 id="gasless-meta-transactions">Gasless Meta Transactions</h1><p>MetaTx-Contracts consists of two main smart contracts designed to work together to provide a comprehensive gasless transaction system.</p>
<h2>Architecture Diagram</h2>
<pre><code class="language-mermaid">flowchart TB
    User[üë§ User] --&gt; Frontend[üñ•Ô∏è Frontend dApp]
    Frontend --&gt; Relayer[ü§ñ Relayer Service]
    Relayer --&gt; Gateway[üîÑ MetaTxGateway]
    Relayer --&gt; Vault[üí∞ GasCreditVault]
    
    Gateway --&gt; Target[üéØ Target Contract]
    Vault --&gt; PriceFeed[üìä Chainlink Price Feed]
    
    subgraph &quot;Core Contracts&quot;
        Gateway
        Vault
    end
    
    subgraph &quot;External Systems&quot;
        Target
        PriceFeed
    end
</code></pre>
<h2>Core Contracts</h2>
<h3>üîÑ MetaTxGateway v1.0.0</h3>
<p><strong>Purpose</strong>: Execute meta-transactions on behalf of users with native token support</p>
<p><strong>Key Features</strong>:</p>
<ul>
<li><strong>Native Token Validation</strong>: Ensures exact native token amounts for transactions</li>
<li><strong>Automatic Refunds</strong>: Returns unused tokens when transactions fail</li>
<li><strong>Batch Processing</strong>: Execute multiple transactions in a single call</li>
<li><strong>EIP-712 Signatures</strong>: Cryptographically secure meta-transaction authorization</li>
<li><strong>UUPS Upgradeable</strong>: Safe upgrade patterns for future enhancements</li>
</ul>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Gasless ERC20 token transfers</li>
<li>Gasless DeFi interactions (swaps, lending, etc.)</li>
<li>Gasless NFT minting and trading</li>
<li>Gasless governance voting</li>
<li>Any contract interaction without gas fees</li>
</ul>
<h3>üí∞ GasCreditVault</h3>
<p><strong>Purpose</strong>: Manage gas credits using various ERC20 tokens with real-time pricing</p>
<p><strong>Key Features</strong>:</p>
<ul>
<li><strong>Multi-Token Support</strong>: Accept USDT, USDC, BUSD, and custom tokens</li>
<li><strong>Chainlink Integration</strong>: Real-time price feeds for accurate conversions</li>
<li><strong>Credit Management</strong>: Deposit, withdraw, transfer, and consume credits</li>
<li><strong>Owner Controls</strong>: Automated fee collection and emergency controls</li>
<li><strong>Price Protection</strong>: Staleness validation and manipulation resistance</li>
</ul>
<p><strong>Use Cases</strong>:</p>
<ul>
<li>Accept stablecoin payments for gas fees</li>
<li>Token-based subscription models</li>
<li>Enterprise gas fee management</li>
<li>Multi-currency gas payment systems</li>
</ul>
<h2>Contract Relationships</h2>
<h3>Transaction Flow</h3>
<ol>
<li><strong>User</strong> creates and signs a meta-transaction using EIP-712</li>
<li><strong>Frontend</strong> calculates required native token value (if any)</li>
<li><strong>Relayer</strong> validates signature and available gas credits</li>
<li><strong>MetaTxGateway</strong> executes the transaction with value validation</li>
<li><strong>GasCreditVault</strong> deducts appropriate credits from user&#39;s balance</li>
<li><strong>Target Contract</strong> receives the function call as if from the original user</li>
</ol>
<h3>Security Model</h3>
<pre><code class="language-mermaid">flowchart LR
    A[User Signature] --&gt; B[EIP-712 Verification]
    B --&gt; C[Nonce Validation]
    C --&gt; D[Relayer Authorization]
    D --&gt; E[Value Validation]
    E --&gt; F[Execution]
    F --&gt; G[Credit Deduction]
    
</code></pre>
<h2>Technical Specifications</h2>
<h3>Solidity Version</h3>
<ul>
<li><strong>Version</strong>: 0.8.20</li>
<li><strong>Optimization</strong>: 200 runs with Via IR</li>
<li><strong>License</strong>: MIT</li>
</ul>
<h3>Dependencies</h3>
<ul>
<li><strong>OpenZeppelin</strong>: v5.3.0 (Upgradeable contracts)</li>
<li><strong>Chainlink</strong>: AggregatorV3Interface for price feeds</li>
<li><strong>EIP-712</strong>: Typed structured data hashing and signing</li>
</ul>
<h3>Gas Optimization</h3>
<ul>
<li>Batch processing reduces per-transaction overhead</li>
<li>Efficient storage layout minimizes SSTORE operations</li>
<li>Optimized loops and conditional logic</li>
<li>Event-driven architecture for off-chain indexing</li>
</ul>
<h2>Security Features</h2>
<h3>MetaTxGateway Security</h3>
<ul>
<li>‚úÖ <strong>Signature Verification</strong>: EIP-712 with replay protection</li>
<li>‚úÖ <strong>Value Validation</strong>: Exact native token amount requirements</li>
<li>‚úÖ <strong>Automatic Refunds</strong>: Protection against fund loss</li>
<li>‚úÖ <strong>Access Controls</strong>: Owner and relayer management</li>
<li>‚úÖ <strong>Reentrancy Protection</strong>: OpenZeppelin ReentrancyGuard</li>
</ul>
<h3>GasCreditVault Security</h3>
<ul>
<li>‚úÖ <strong>Price Feed Validation</strong>: Chainlink oracle integration</li>
<li>‚úÖ <strong>Staleness Protection</strong>: Time-based price validation</li>
<li>‚úÖ <strong>Emergency Controls</strong>: Pause and withdrawal mechanisms</li>
<li>‚úÖ <strong>Multi-Token Validation</strong>: Comprehensive token support checks</li>
<li>‚úÖ <strong>Owner Controls</strong>: Secure fee collection and management</li>
</ul>
<h2>Upgrade Strategy</h2>
<p>Both contracts use the <strong>UUPS (Universal Upgradeable Proxy Standard)</strong> pattern:</p>
<ul>
<li><strong>Proxy Contract</strong>: Stores state and delegates calls to implementation</li>
<li><strong>Implementation Contract</strong>: Contains the business logic</li>
<li><strong>Upgrade Authorization</strong>: Only contract owner can authorize upgrades</li>
<li><strong>Storage Safety</strong>: Careful storage layout management prevents collisions</li>
</ul>
<h3>Storage Layout</h3>
<pre><code class="language-solidity">// MetaTxGateway Storage Layout
mapping(address =&gt; bool) public authorizedRelayers;           // Slot 0
mapping(address =&gt; uint256) public nonces;                    // Slot 1
mapping(uint256 =&gt; BatchTransactionLog) public batchTransactionLogs; // Slot 2
uint256 public nextBatchId;                                   // Slot 3
mapping(uint256 =&gt; MetaTransaction[]) public batchTransactions; // Slot 4
</code></pre>
<h2>Network Support</h2>
<h3>Mainnet Deployments</h3>
<ul>
<li><strong>BSC Mainnet</strong>: Production ready</li>
<li><strong>Ethereum Mainnet</strong>: Production ready</li>
<li><strong>Polygon Mainnet</strong>: Production ready</li>
</ul>
<h3>Testnet Deployments</h3>
<ul>
<li><strong>BSC Testnet</strong>: Development and testing</li>
<li><strong>Ethereum Sepolia</strong>: Development and testing</li>
<li><strong>Polygon Mumbai</strong>: Development and testing</li>
</ul>
<h2>Performance Metrics</h2>
<h3>Gas Costs (Approximate)</h3>
<ul>
<li><strong>Single Meta-Transaction</strong>: ~150,000 gas</li>
<li><strong>Batch (5 transactions)</strong>: ~400,000 gas (80,000 per tx)</li>
<li><strong>Credit Deposit</strong>: ~80,000 gas</li>
<li><strong>Credit Withdrawal</strong>: ~60,000 gas</li>
</ul>
<h3>Throughput</h3>
<ul>
<li><strong>Transactions per second</strong>: Limited by block gas limit</li>
<li><strong>Batch efficiency</strong>: 30-40% gas savings for multiple transactions</li>
<li><strong>Scalability</strong>: Horizontal scaling through multiple relayers</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li><strong><a href="metatxgateway.md">MetaTxGateway Details</a></strong> - Deep dive into the gateway contract</li>
<li><strong><a href="gascreditvault.md">GasCreditVault Details</a></strong> - Explore the credit system</li>
<li><strong><a href="../deployment/deployment-guide.md">Deployment Guide</a></strong> - Deploy your own instance</li>
<li><strong><a href="../integration/frontend-integration.md">Integration Guide</a></strong> - Add to your dApp</li>
</ul>
<div class="page-break"></div><h1 id="cross-chain-bridge">Cross-Chain Bridge</h1><p>IU2U Protocol implements a robust cross-chain architecture that enables seamless interoperability between different blockchain networks while maintaining security and decentralization.</p>
<h2>Architecture Overview</h2>
<pre><code class="language-mermaid">flowchart TB
    subgraph &quot;Source Chain&quot;
        SC[Smart Contract]
        SG[IU2U Gateway]
        SE[Event Emitter]
    end
    
    subgraph &quot;Relayer Network&quot;
        R1[Relayer 1]
        R2[Relayer 2]
        R3[Relayer N]
        MS[Multi-Sig Validator]
    end
    
    subgraph &quot;Destination Chain&quot;
        DG[IU2U Gateway]
        DC[Destination Contract]
        DE[Event Processor]
    end
    
    SC --&gt; SG
    SG --&gt; SE
    SE --&gt; R1
    SE --&gt; R2
    SE --&gt; R3
    R1 --&gt; MS
    R2 --&gt; MS
    R3 --&gt; MS
    MS --&gt; DG
    DG --&gt; DC
    DC --&gt; DE
</code></pre>
<h2>Core Components</h2>
<h3>1. IU2U Gateway</h3>
<p>The gateway contract serves as the primary interface for cross-chain operations:</p>
<ul>
<li><strong>Event Emission</strong>: Captures and emits cross-chain transaction events</li>
<li><strong>Command Validation</strong>: Validates incoming cross-chain commands</li>
<li><strong>Security Enforcement</strong>: Implements multi-signature and replay protection</li>
<li><strong>State Management</strong>: Maintains cross-chain state synchronization</li>
</ul>
<h3>2. Relayer Network</h3>
<p>A decentralized network of validators that process cross-chain messages:</p>
<ul>
<li><strong>Event Monitoring</strong>: Continuously monitors source chain events</li>
<li><strong>Message Relaying</strong>: Securely transmits messages between chains</li>
<li><strong>Consensus Mechanism</strong>: Multi-signature validation for security</li>
<li><strong>Finality Confirmation</strong>: Waits for block confirmations before processing</li>
</ul>
<h3>3. Command System</h3>
<p>Standardized command types for different operations:</p>
<pre><code class="language-solidity">// Core command types
uint256 COMMAND_APPROVE_CONTRACT_CALL = 0;
uint256 COMMAND_APPROVE_CONTRACT_CALL_WITH_MINT = 1;
uint256 COMMAND_BURN_TOKEN = 2;
uint256 COMMAND_MINT_TOKEN = 4;
</code></pre>
<h2>Cross-Chain Message Flow</h2>
<h3>1. Message Initiation</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Gateway_A as Gateway (Chain A)
    participant Event_A as Event System (Chain A)
    
    User-&gt;&gt;Gateway_A: Call contract function
    Gateway_A-&gt;&gt;Gateway_A: Validate parameters
    Gateway_A-&gt;&gt;Event_A: Emit ContractCall event
    Event_A-&gt;&gt;Event_A: Include in block
</code></pre>
<h3>2. Relayer Processing</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant Event_A as Event System (Chain A)
    participant Relayer as Relayer Network
    participant Validator as Multi-Sig Validator
    
    Event_A-&gt;&gt;Relayer: Event detected
    Relayer-&gt;&gt;Relayer: Wait for confirmations
    Relayer-&gt;&gt;Validator: Submit for validation
    Validator-&gt;&gt;Validator: Multi-sig consensus
    Validator-&gt;&gt;Relayer: Approve command
</code></pre>
<h3>3. Message Execution</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant Relayer as Relayer Network
    participant Gateway_B as Gateway (Chain B)
    participant Contract_B as Target Contract (Chain B)
    
    Relayer-&gt;&gt;Gateway_B: Submit approved command
    Gateway_B-&gt;&gt;Gateway_B: Verify signatures
    Gateway_B-&gt;&gt;Contract_B: Execute payload
    Contract_B-&gt;&gt;Gateway_B: Return result
    Gateway_B-&gt;&gt;Relayer: Confirm execution
    
</code></pre>
<h2>Security Architecture</h2>
<h3>Multi-Signature Validation</h3>
<p>The protocol employs a robust multi-signature scheme:</p>
<pre><code class="language-solidity">struct Command {
    uint256 commandType;
    bytes data;
    bytes32[] signatures;
    uint256 threshold;
}

function validateCommand(Command memory cmd) internal view returns (bool) {
    require(cmd.signatures.length &gt;= cmd.threshold, &quot;Insufficient signatures&quot;);
    // Validate each signature against authorized relayers
    return true;
}
</code></pre>
<h3>Key Security Features</h3>
<ol>
<li><strong>Signature Verification</strong>: All cross-chain commands require valid signatures</li>
<li><strong>Replay Protection</strong>: Command IDs prevent duplicate execution</li>
<li><strong>Threshold Security</strong>: Configurable signature thresholds</li>
<li><strong>Relayer Rotation</strong>: Dynamic relayer set management</li>
<li><strong>Emergency Pause</strong>: Circuit breakers for security incidents</li>
</ol>
<h3>Threat Mitigation</h3>
<table>
<thead>
<tr>
<th>Threat</th>
<th>Mitigation Strategy</th>
</tr>
</thead>
<tbody><tr>
<td>Relayer Compromise</td>
<td>Multi-signature threshold voting</td>
</tr>
<tr>
<td>Replay Attacks</td>
<td>Unique command IDs and nonce tracking</td>
</tr>
<tr>
<td>Front-running</td>
<td>Commit-reveal schemes where applicable</td>
</tr>
<tr>
<td>MEV Exploitation</td>
<td>Fair ordering mechanisms</td>
</tr>
<tr>
<td>Chain Reorganization</td>
<td>Deep confirmation requirements</td>
</tr>
</tbody></table>
<h2>Chain Integration Process</h2>
<h3>1. Technical Requirements</h3>
<p>New chain integration requires:</p>
<ul>
<li><strong>EVM Compatibility</strong>: Smart contract deployment capability</li>
<li><strong>Event System</strong>: Reliable event emission and querying</li>
<li><strong>RPC Access</strong>: Stable RPC endpoints for relayers</li>
<li><strong>Block Finality</strong>: Deterministic finality mechanisms</li>
</ul>
<h3>2. Deployment Process</h3>
<pre><code class="language-mermaid">flowchart LR
    A[Contract Deployment] --&gt; B[Relayer Configuration]
    B --&gt; C[Security Audit]
    C --&gt; D[Testnet Testing]
    D --&gt; E[Mainnet Deployment]
    E --&gt; F[Relayer Activation]
</code></pre>
<h3>3. Configuration Parameters</h3>
<pre><code class="language-javascript">// Chain configuration example
const chainConfig = {
    chainId: 1,
    name: &quot;ethereum&quot;,
    rpc: &quot;https://mainnet.infura.io/v3/...&quot;,
    gasLimit: 500000,
    blockConfirmations: 12,
    contracts: {
        gateway: &quot;0x...&quot;,
        token: &quot;0x...&quot;
    }
};
</code></pre>
<h2>Performance Characteristics</h2>
<h3>Latency Metrics</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Time</th>
<th>Factors</th>
</tr>
</thead>
<tbody><tr>
<td>Event Detection</td>
<td>1-3 blocks</td>
<td>Chain block time</td>
</tr>
<tr>
<td>Relayer Processing</td>
<td>30-60 seconds</td>
<td>Confirmation requirements</td>
</tr>
<tr>
<td>Command Execution</td>
<td>1-2 blocks</td>
<td>Destination chain congestion</td>
</tr>
<tr>
<td>End-to-End</td>
<td>2-5 minutes</td>
<td>Combined factors</td>
</tr>
</tbody></table>
<h3>Throughput Capacity</h3>
<ul>
<li><strong>Theoretical Max</strong>: 1000 TPS (limited by slowest chain)</li>
<li><strong>Practical Throughput</strong>: 100-500 TPS</li>
<li><strong>Batching Support</strong>: Multiple commands per transaction</li>
<li><strong>Parallel Processing</strong>: Independent relayer operation</li>
</ul>
<h2>Gas Optimization</h2>
<h3>Efficient Command Encoding</h3>
<pre><code class="language-solidity">// Optimized command structure
struct CompactCommand {
    uint8 commandType;      // 1 byte
    bytes20 target;         // 20 bytes  
    uint256 value;          // 32 bytes
    bytes data;             // Variable length
}
</code></pre>
<h3>Batch Operations</h3>
<pre><code class="language-solidity">// Execute multiple commands in single transaction
function executeBatch(CompactCommand[] memory commands) external {
    for (uint i = 0; i &lt; commands.length; i++) {
        _executeCommand(commands[i]);
    }
}
</code></pre>
<h2>Monitoring and Analytics</h2>
<h3>Event Tracking</h3>
<p>The protocol provides comprehensive event tracking:</p>
<pre><code class="language-solidity">event CrossChainCall(
    bytes32 indexed commandId,
    string indexed sourceChain,
    string indexed destinationChain,
    address sender,
    bytes payload
);

event CommandExecuted(
    bytes32 indexed commandId,
    bool success,
    bytes returnData
);
</code></pre>
<h3>Metrics Dashboard</h3>
<p>Key metrics monitored:</p>
<ul>
<li>Cross-chain transaction volume</li>
<li>Average execution time</li>
<li>Success/failure rates  </li>
<li>Relayer performance</li>
<li>Gas consumption patterns</li>
</ul>
<h2>Error Handling</h2>
<h3>Failure Scenarios</h3>
<ol>
<li><strong>Network Partitions</strong>: Automatic retry mechanisms</li>
<li><strong>Invalid Commands</strong>: Graceful rejection with detailed errors</li>
<li><strong>Gas Limit Exceeded</strong>: Dynamic gas estimation</li>
<li><strong>Relayer Unavailability</strong>: Redundant relayer selection</li>
</ol>
<h3>Recovery Mechanisms</h3>
<pre><code class="language-solidity">// Manual command retry for failed transactions
function retryCommand(bytes32 commandId) external onlyOwner {
    require(!commandExecuted[commandId], &quot;Already executed&quot;);
    // Re-attempt execution with updated parameters
}
</code></pre>
<h2>Future Enhancements</h2>
<h3>Planned Improvements</h3>
<ol>
<li><strong>Zero-Knowledge Proofs</strong>: Enhanced privacy for cross-chain operations</li>
<li><strong>Optimistic Execution</strong>: Faster finality with fraud proofs</li>
<li><strong>Cross-Chain DEX</strong>: Native cross-chain trading without bridging</li>
<li><strong>Advanced Governance</strong>: Chain-specific governance mechanisms</li>
</ol>
<h3>Research Areas</h3>
<ul>
<li><strong>Interoperability Standards</strong>: Adoption of emerging cross-chain standards</li>
<li><strong>Scalability Solutions</strong>: Layer 2 integration and parallel processing</li>
<li><strong>Security Enhancements</strong>: Formal verification and automated auditing</li>
<li><strong>User Experience</strong>: Simplified interfaces and gasless transactions</li>
</ul>
<h2>Integration Guidelines</h2>
<h3>For Developers</h3>
<ol>
<li><strong>Contract Integration</strong>: Implement <code>IU2UExecutable</code> interface</li>
<li><strong>Event Handling</strong>: Properly handle asynchronous execution</li>
<li><strong>Error Management</strong>: Implement robust error handling</li>
<li><strong>Testing</strong>: Comprehensive testing across all supported chains</li>
</ol>
<h3>For Relayers</h3>
<ol>
<li><strong>Infrastructure</strong>: Reliable RPC access and monitoring</li>
<li><strong>Security</strong>: Secure key management and HSM integration</li>
<li><strong>Performance</strong>: Optimized event processing and batching</li>
<li><strong>Compliance</strong>: Adherence to relayer network policies</li>
</ol>
<h2>Resources</h2>
<ul>
<li><a href="../cross-chain/message-passing.md">Message Passing Guide</a></li>
<li><a href="../cross-chain/token-transfers.md">Token Transfer Implementation</a></li>
<li><a href="../guides/security.md">Security Best Practices</a></li>
<li><a href="relayer-network.md">Relayer Network Details</a></li>
</ul>
<div class="page-break"></div><h1 id="dex-aggregation">DEX Aggregation</h1><p>IU2U Protocol includes one of the most comprehensive DEX aggregation systems in DeFi, supporting 37+ protocols across 7 blockchain networks for optimal trading execution.</p>
<h2>Why DEX Aggregation?</h2>
<h3>The Fragmentation Problem</h3>
<p>Modern DeFi spans multiple chains and hundreds of DEX protocols, each with:</p>
<ul>
<li>Different liquidity pools</li>
<li>Varying fee structures  </li>
<li>Unique token pairs</li>
<li>Inconsistent pricing</li>
</ul>
<p><strong>Without aggregation, users face:</strong></p>
<ul>
<li>‚ùå Manual comparison across multiple DEXes</li>
<li>‚ùå Suboptimal pricing due to limited liquidity</li>
<li>‚ùå High gas costs from multiple transactions</li>
<li>‚ùå Complex cross-chain operations</li>
</ul>
<p><strong>With IU2U aggregation:</strong></p>
<ul>
<li>‚úÖ Automatic best price discovery</li>
<li>‚úÖ Single transaction execution</li>
<li>‚úÖ Cross-chain routing optimization</li>
<li>‚úÖ Unified interface across all protocols</li>
</ul>
<h2>Architecture Overview</h2>
<pre><code class="language-mermaid">flowchart TB
    subgraph &quot;User Interface&quot;
        UI[User Request]
        SDK[IU2U SDK]
    end
    
    subgraph &quot;Aggregation Layer&quot;
        CCA[CrossChainAggregator]
        ML[MulticallLibraryV2]
        QL[QuoteLibrary]
    end
    
    subgraph &quot;DEX Protocols&quot;
        V2[V2 AMMs]
        V3[V3 Concentrated Liquidity]
        SF[Solidly Forks]
        SS[Stableswap]
        SP[Specialized Protocols]
    end
    
    subgraph &quot;Blockchain Networks&quot;
        ETH[Ethereum]
        BSC[BSC]
        POLY[Polygon]
        AVAX[Avalanche]
        ARB[Arbitrum]
        OP[Optimism]
        BASE[Base]
    end
    
    UI --&gt; SDK
    SDK --&gt; CCA
    CCA --&gt; ML
    ML --&gt; QL
    QL --&gt; V2
    QL --&gt; V3
    QL --&gt; SF
    QL --&gt; SS
    QL --&gt; SP
    
    V2 --&gt; ETH
    V2 --&gt; BSC
    V2 --&gt; POLY
    V3 --&gt; ETH
    V3 --&gt; ARB
    SF --&gt; OP
    SS --&gt; ETH
    SP --&gt; BASE
</code></pre>
<h2>Supported DEX Categories</h2>
<h3>V2 AMM Protocols</h3>
<p>Traditional Automated Market Makers using the constant product formula (x*y=k):</p>
<p><strong>Major Protocols:</strong></p>
<ul>
<li><strong>Uniswap V2</strong> - Original AMM standard</li>
<li><strong>SushiSwap V2</strong> - Community-driven fork</li>
<li><strong>PancakeSwap V2</strong> - BSC&#39;s leading DEX</li>
<li><strong>QuickSwap</strong> - Polygon&#39;s fastest DEX</li>
<li><strong>TraderJoe V1</strong> - Avalanche&#39;s premier DEX</li>
</ul>
<p><strong>Characteristics:</strong></p>
<ul>
<li>‚úÖ Simple pricing model</li>
<li>‚úÖ High liquidity for major pairs</li>
<li>‚úÖ Proven security track record</li>
<li>‚ùå Capital inefficiency</li>
<li>‚ùå Impermanent loss for LPs</li>
</ul>
<h3>V3 Concentrated Liquidity</h3>
<p>Advanced AMMs with concentrated liquidity positions:</p>
<p><strong>Leading Protocols:</strong></p>
<ul>
<li><strong>Uniswap V3</strong> - Concentrated liquidity pioneer</li>
<li><strong>SushiSwap V3</strong> - Enhanced V3 implementation</li>
<li><strong>PancakeSwap V3</strong> - BSC concentrated liquidity</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul>
<li>‚úÖ Capital efficiency (up to 4000x)</li>
<li>‚úÖ Custom fee tiers</li>
<li>‚úÖ Active liquidity management</li>
<li>‚úÖ Better pricing for large trades</li>
<li>‚ùå Complexity for liquidity providers</li>
<li>‚ùå Impermanent loss amplification</li>
</ul>
<p><strong>Fee Tiers:</strong></p>
<ul>
<li><strong>0.01%</strong> (100): Stablecoin pairs</li>
<li><strong>0.05%</strong> (500): Stable pairs with some volatility</li>
<li><strong>0.30%</strong> (3000): Most pairs</li>
<li><strong>1.00%</strong> (10000): Exotic pairs</li>
</ul>
<h3>Solidly Forks (ve(3,3))</h3>
<p>Protocols based on Andre Cronje&#39;s Solidly design:</p>
<p><strong>Key Protocols:</strong></p>
<ul>
<li><strong>Velodrome</strong> (Optimism) - Leading ve(3,3) protocol</li>
<li><strong>Aerodrome</strong> (Base) - Coinbase L2 implementation</li>
<li><strong>Thena</strong> (BSC) - Multi-chain ve(3,3)</li>
<li><strong>Ramses</strong> (Arbitrum) - Arbitrum&#39;s ve(3,3) protocol</li>
</ul>
<p><strong>Features:</strong></p>
<ul>
<li>‚úÖ Dual pool types (volatile + stable)</li>
<li>‚úÖ Emissions voting mechanism</li>
<li>‚úÖ Protocol-owned liquidity</li>
<li>‚úÖ Reduced impermanent loss for stable pairs</li>
</ul>
<h3>Stableswap Protocols</h3>
<p>Specialized AMMs optimized for correlated assets:</p>
<p><strong>Major Protocols:</strong></p>
<ul>
<li><strong>Curve Finance</strong> - Stablecoin trading pioneer</li>
<li><strong>Ellipsis Finance</strong> - BSC&#39;s Curve implementation</li>
<li><strong>Belt Finance</strong> - Multi-asset yield farming</li>
</ul>
<p><strong>Optimizations:</strong></p>
<ul>
<li>‚úÖ Minimal slippage for stable pairs</li>
<li>‚úÖ Capital efficiency for correlated assets</li>
<li>‚úÖ Yield farming integration</li>
<li>‚úÖ Metapool support</li>
</ul>
<h3>Specialized Protocols</h3>
<p>Unique DEX designs with specific use cases:</p>
<p><strong>Notable Protocols:</strong></p>
<ul>
<li><strong>Balancer V2</strong> - Multi-asset weighted pools</li>
<li><strong>1inch</strong> - Meta-aggregation protocol</li>
<li><strong>DODO</strong> - Proactive Market Maker (PMM)</li>
<li><strong>WooFi</strong> - Synthetic proactive market making</li>
<li><strong>Platypus</strong> - Single-sided stablecoin AMM</li>
</ul>
<h2>Routing Algorithm</h2>
<h3>Multi-Hop Routing</h3>
<p>IU2U&#39;s routing algorithm finds optimal paths across multiple protocols:</p>
<pre><code class="language-mermaid">flowchart LR
    A[Token A] --&gt; B[WETH]
    A --&gt; C[USDC]
    A --&gt; D[DAI]
    
    B --&gt; E[Token B]
    C --&gt; E
    D --&gt; E
    
    subgraph &quot;Route 1&quot;
        A1[Uniswap V2] --&gt; B1[SushiSwap V3]
    end
    
    subgraph &quot;Route 2&quot;
        A2[Curve] --&gt; B2[Balancer]
    end
    
    subgraph &quot;Route 3&quot;
        A3[Direct Path] --&gt; B3[Uniswap V3]
    end
</code></pre>
<h3>Route Optimization</h3>
<p><strong>Factors Considered:</strong></p>
<ol>
<li><strong>Price Impact</strong> - Slippage minimization</li>
<li><strong>Gas Costs</strong> - Transaction fee optimization</li>
<li><strong>Liquidity Depth</strong> - Available token reserves</li>
<li><strong>Protocol Fees</strong> - DEX-specific charges</li>
<li><strong>Split Routing</strong> - Distributing trades across multiple paths</li>
</ol>
<p><strong>Algorithm Steps:</strong></p>
<ol>
<li><strong>Quote Generation</strong> - Get prices from all 37 protocols</li>
<li><strong>Path Discovery</strong> - Find viable multi-hop routes</li>
<li><strong>Split Optimization</strong> - Determine optimal trade distribution</li>
<li><strong>Gas Estimation</strong> - Calculate execution costs</li>
<li><strong>Best Route Selection</strong> - Maximize net output</li>
</ol>
<h3>Smart Routing Features</h3>
<p><strong>Split Routing:</strong></p>
<pre><code class="language-javascript">// Example: $10,000 USDC ‚Üí WETH split across protocols
{
  &quot;totalAmountIn&quot;: &quot;10000000000&quot;, // 10,000 USDC
  &quot;routes&quot;: [
    {
      &quot;protocol&quot;: &quot;Uniswap V3&quot;,
      &quot;percentage&quot;: 45,
      &quot;amountIn&quot;: &quot;4500000000&quot;,
      &quot;expectedOut&quot;: &quot;1.234 ETH&quot;
    },
    {
      &quot;protocol&quot;: &quot;SushiSwap V2&quot;, 
      &quot;percentage&quot;: 35,
      &quot;amountIn&quot;: &quot;3500000000&quot;,
      &quot;expectedOut&quot;: &quot;0.956 ETH&quot;
    },
    {
      &quot;protocol&quot;: &quot;Curve&quot;,
      &quot;percentage&quot;: 20,
      &quot;amountIn&quot;: &quot;2000000000&quot;, 
      &quot;expectedOut&quot;: &quot;0.543 ETH&quot;
    }
  ],
  &quot;totalExpectedOut&quot;: &quot;2.733 ETH&quot;,
  &quot;priceImpact&quot;: &quot;0.12%&quot;,
  &quot;gasEstimate&quot;: &quot;450000&quot;
}
</code></pre>
<h2>Quote System</h2>
<h3>Real-Time Price Discovery</h3>
<p>The quote system provides instant price comparisons across all supported protocols:</p>
<p><strong>Quote Sources:</strong></p>
<ul>
<li><strong>On-chain calls</strong> to DEX contracts</li>
<li><strong>Subgraph queries</strong> for historical data</li>
<li><strong>Price oracles</strong> for validation</li>
<li><strong>Mempool analysis</strong> for MEV protection</li>
</ul>
<h3>Quote Comparison</h3>
<pre><code class="language-javascript">async function compareQuotes(tokenIn, tokenOut, amountIn) {
  const quotes = await aggregator.getAllQuotes(tokenIn, tokenOut, amountIn);
  
  return quotes.map(quote =&gt; ({
    protocol: getDEXName(quote.routerType),
    amountOut: quote.amountOut,
    priceImpact: calculatePriceImpact(quote),
    gasEstimate: quote.gasEstimate,
    netOutput: quote.amountOut.sub(quote.gasEstimate)
  })).sort((a, b) =&gt; b.netOutput.sub(a.netOutput));
}
</code></pre>
<h3>Dynamic Updates</h3>
<p><strong>Quote Refresh Strategy:</strong></p>
<ul>
<li><strong>Block-based updates</strong> for high-frequency pairs</li>
<li><strong>Time-based refresh</strong> for standard pairs</li>
<li><strong>Event-driven updates</strong> for liquidity changes</li>
<li><strong>User-triggered refresh</strong> for manual updates</li>
</ul>
<h2>Cross-Chain Aggregation</h2>
<h3>Cross-Chain Swap Flow</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Aggregator_A as Aggregator (Chain A)
    participant IU2U_A as IU2U Gateway (Chain A) 
    participant Relayer
    participant IU2U_B as IU2U Gateway (Chain B)
    participant Aggregator_B as Aggregator (Chain B)
    
    User-&gt;&gt;Aggregator_A: Swap Token A ‚Üí Token B (cross-chain)
    Aggregator_A-&gt;&gt;Aggregator_A: Find best route A ‚Üí IU2U
    Aggregator_A-&gt;&gt;IU2U_A: Execute swap A ‚Üí IU2U
    IU2U_A-&gt;&gt;Relayer: Bridge IU2U to Chain B
    Relayer-&gt;&gt;IU2U_B: Deliver IU2U + swap instructions
    IU2U_B-&gt;&gt;Aggregator_B: Execute swap IU2U ‚Üí Token B
    Aggregator_B-&gt;&gt;User: Deliver Token B
    
</code></pre>
<h3>Cross-Chain Route Optimization</h3>
<p><strong>Considerations:</strong></p>
<ul>
<li><strong>Bridge costs</strong> and timing</li>
<li><strong>Destination chain liquidity</strong></li>
<li><strong>Gas price differences</strong></li>
<li><strong>MEV protection across chains</strong></li>
</ul>
<h2>Performance Metrics</h2>
<h3>Speed Benchmarks</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Response Time</th>
<th>Success Rate</th>
</tr>
</thead>
<tbody><tr>
<td>Single quote</td>
<td>&lt;100ms</td>
<td>99.9%</td>
</tr>
<tr>
<td>All quotes (37 DEXes)</td>
<td>&lt;500ms</td>
<td>99.5%</td>
</tr>
<tr>
<td>Route optimization</td>
<td>&lt;200ms</td>
<td>99.8%</td>
</tr>
<tr>
<td>Cross-chain quote</td>
<td>&lt;2s</td>
<td>99.0%</td>
</tr>
</tbody></table>
<h3>Cost Savings</h3>
<p><strong>Gas Optimization:</strong></p>
<ul>
<li><strong>Batch operations</strong>: 40-60% gas savings</li>
<li><strong>Route optimization</strong>: 15-30% price improvement</li>
<li><strong>MEV protection</strong>: 2-5% value preservation</li>
</ul>
<p><strong>Comparison vs Direct DEX:</strong></p>
<pre><code>Direct Uniswap V2:     1.245 ETH (gas: $25)
IU2U Aggregated:       1.287 ETH (gas: $18)
Improvement:           +3.4% tokens, -28% gas
</code></pre>
<h2>Integration Examples</h2>
<h3>Basic Swap</h3>
<pre><code class="language-javascript">import { CrossChainAggregator } from &#39;@iu2u/sdk&#39;;

async function performAggregatedSwap() {
  const aggregator = new CrossChainAggregator({ network: &#39;mainnet&#39; });
  
  // Get optimal route
  const quote = await aggregator.getOptimalQuote(
    &#39;0xA0b86a33E6441e1a02c4e4670dd96EA0f25A632&#39;, // USDC
    &#39;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&#39;, // WETH
    ethers.utils.parseUnits(&#39;1000&#39;, 6) // 1000 USDC
  );
  
  console.log(`Best price: ${quote.bestAmount} WETH`);
  console.log(`From: ${quote.dexName}`);
  console.log(`Price impact: ${quote.priceImpact}%`);
  
  // Execute swap
  const tx = await aggregator.executeSwap({
    tokenIn: &#39;0xA0b86a33E6441e1a02c4e4670dd96EA0f25A632&#39;,
    tokenOut: &#39;0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2&#39;,
    amountIn: ethers.utils.parseUnits(&#39;1000&#39;, 6),
    minAmountOut: quote.bestAmount.mul(995).div(1000), // 0.5% slippage
    routerType: quote.bestRouter
  });
  
  return tx;
}
</code></pre>
<h3>Advanced Multi-Route</h3>
<pre><code class="language-javascript">async function advancedRouting() {
  // Compare specific protocols only
  const preferredDEXes = [
    0,  // Uniswap V2
    10, // Uniswap V3  
    1,  // SushiSwap V2
    11, // SushiSwap V3
    30  // Curve
  ];
  
  const quotes = await aggregator.getQuotesForRouters(
    tokenIn,
    tokenOut, 
    amountIn,
    preferredDEXes
  );
  
  // Custom selection logic
  const bestQuote = quotes.find(q =&gt; 
    q.priceImpact &lt; 0.5 &amp;&amp; // Max 0.5% price impact
    q.gasEstimate &lt; ethers.utils.parseUnits(&#39;200&#39;, &#39;gwei&#39;) // Reasonable gas
  ) || quotes[0]; // Fallback to best price
  
  return aggregator.executeSwap({
    ...swapParams,
    routerType: bestQuote.routerType
  });
}
</code></pre>
<h2>Security Considerations</h2>
<h3>MEV Protection</h3>
<p><strong>Protection Mechanisms:</strong></p>
<ul>
<li><strong>Private mempool submission</strong></li>
<li><strong>Flashloan sandwich detection</strong></li>
<li><strong>Price impact monitoring</strong></li>
<li><strong>Revert on unexpected slippage</strong></li>
</ul>
<h3>Smart Contract Security</h3>
<p><strong>Risk Mitigation:</strong></p>
<ul>
<li><strong>Router contract verification</strong></li>
<li><strong>Slippage protection enforcement</strong></li>
<li><strong>Deadline validation</strong></li>
<li><strong>Reentrancy guards</strong></li>
</ul>
<h3>Oracle Reliability</h3>
<p><strong>Price Validation:</strong></p>
<ul>
<li><strong>Multiple price sources</strong></li>
<li><strong>Deviation thresholds</strong></li>
<li><strong>Circuit breakers</strong></li>
<li><strong>Manual override capabilities</strong></li>
</ul>
<h2>Future Enhancements</h2>
<h3>Planned Features</h3>
<p><strong>Q1 2024:</strong></p>
<ul>
<li>‚úÖ Intent-based routing</li>
<li>‚úÖ Just-in-time liquidity</li>
<li>‚úÖ Cross-chain MEV protection</li>
</ul>
<p><strong>Q2 2024:</strong></p>
<ul>
<li>üîÑ Solver network integration</li>
<li>üîÑ Advanced order types</li>
<li>üîÑ Portfolio rebalancing</li>
</ul>
<p><strong>Q3 2024:</strong></p>
<ul>
<li>üìã Options protocol integration</li>
<li>üìã Lending market routing</li>
<li>üìã Yield farming optimization</li>
</ul>
<h3>Research Areas</h3>
<ul>
<li><strong>Machine learning</strong> for price prediction</li>
<li><strong>Game theory</strong> for MEV mitigation</li>
<li><strong>ZK proofs</strong> for privacy-preserving routing</li>
<li><strong>Intent-based architecture</strong> for user experience</li>
</ul>
<h2>Next Steps</h2>
<p>Learn more about specific aspects:</p>
<ol>
<li><strong><a href="supported-dexes.md">Supported DEXes</a></strong> - Complete protocol list</li>
<li><strong><a href="routing-algorithm.md">Routing Algorithm</a></strong> - Technical deep dive</li>
<li><strong><a href="quote-system.md">Quote System</a></strong> - Price discovery mechanics</li>
<li><strong><a href="router-types.md">Router Types</a></strong> - Protocol categorization</li>
</ol>
<p>Ready to integrate? Check out our <a href="../examples/dex-aggregation.md">Integration Examples</a>!</p>
<div class="page-break"></div><h1 id="metatx-gateway">MetaTx Gateway</h1><p>The MetaTxGateway is the core contract responsible for executing gasless meta-transactions with built-in native token support and automatic refund mechanisms.</p>
<p><strong>This protocol also includes the DI Token, Token Presale, and Token Staking contracts, providing a complete tokenomics suite.</strong></p>
<h2>Overview</h2>
<p>MetaTxGateway v1.0.0-native-token-support enables secure, gasless meta-transactions with native token (ETH/BNB) support, batch execution, and relayer authorization.</p>
<h2>Key Features</h2>
<h3>üîí Native Token Validation</h3>
<p>Ensures exact native token amounts are provided for meta-transactions that require ETH/BNB transfers.</p>
<h3>üîÑ Automatic Refunds</h3>
<p>Returns unused native tokens to users when transactions fail, preventing fund loss.</p>
<h3>üì¶ Batch Processing</h3>
<p>Execute multiple transactions in a single call, reducing gas costs and improving efficiency.</p>
<h3>üñãÔ∏è EIP-712 Signatures</h3>
<p>Cryptographically secure meta-transaction authorization with structured data signing.</p>
<h3>üîß UUPS Upgradeable</h3>
<p>Safe upgrade patterns for future enhancements without disrupting existing functionality.</p>
<h3>‚è∏Ô∏è Pausable</h3>
<p>Owner can pause/unpause contract with a reason.</p>
<h2>Contract Interface</h2>
<h3>Core Functions</h3>
<h4>executeMetaTransactions</h4>
<pre><code class="language-solidity">function executeMetaTransactions(
    address from,
    MetaTransaction[] calldata metaTxs,
    bytes calldata signature,
    uint256 nonce,
    uint256 deadline
) external payable nonReentrant whenNotPaused returns (bool[] memory successes)
</code></pre>
<p><strong>Purpose</strong>: Execute a batch of meta-transactions on behalf of a user.</p>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>from</code>: The user&#39;s address (signature signer)</li>
<li><code>metaTxs</code>: Array of MetaTransaction structs</li>
<li><code>signature</code>: EIP-712 signature from the user</li>
<li><code>nonce</code>: User&#39;s current nonce for replay protection</li>
<li><code>deadline</code>: Transaction expiration timestamp</li>
</ul>
<p><strong>Returns</strong>: Array of boolean values indicating success/failure for each transaction</p>
<p><strong>Key Validations</strong>:</p>
<ul>
<li>Relayer authorization check</li>
<li>Signature verification using EIP-712</li>
<li>Nonce validation for replay protection</li>
<li>Native token amount validation</li>
<li>Deadline enforcement</li>
</ul>
<h4>calculateRequiredValue</h4>
<pre><code class="language-solidity">function calculateRequiredValue(MetaTransaction[] calldata metaTxs) 
    external pure returns (uint256 totalValue)
</code></pre>
<p><strong>Purpose</strong>: Calculate the total native token value required for a batch of meta-transactions.</p>
<p><strong>Use Case</strong>: Frontend applications can use this to determine how much ETH/BNB to include with the relayer transaction.</p>
<h4>setRelayerAuthorization</h4>
<pre><code class="language-solidity">function setRelayerAuthorization(address relayer, bool authorized) 
    external onlyOwner
</code></pre>
<p><strong>Purpose</strong>: Authorize or deauthorize a relayer address.</p>
<h4>pauseWithReason</h4>
<pre><code class="language-solidity">function pauseWithReason(string calldata reason) external onlyOwner
</code></pre>
<p><strong>Purpose</strong>: Pause the contract with a reason.</p>
<h4>unpause</h4>
<pre><code class="language-solidity">function unpause() external onlyOwner
</code></pre>
<p><strong>Purpose</strong>: Unpause the contract.</p>
<h3>View Functions</h3>
<h4>getNonce</h4>
<pre><code class="language-solidity">function getNonce(address user) external view returns (uint256 currentNonce)
</code></pre>
<p><strong>Purpose</strong>: Get the current nonce for a user address.</p>
<h4>isRelayerAuthorized</h4>
<pre><code class="language-solidity">function isRelayerAuthorized(address relayer) external view returns (bool isAuthorized)
</code></pre>
<p><strong>Purpose</strong>: Check if a relayer is authorized.</p>
<h4>getDomainSeparator</h4>
<pre><code class="language-solidity">function getDomainSeparator() external view returns (bytes32 separator)
</code></pre>
<p><strong>Purpose</strong>: Get the EIP-712 domain separator for signature verification.</p>
<h4>getMetaTransactionTypehash</h4>
<pre><code class="language-solidity">function getMetaTransactionTypehash() external pure returns (bytes32 typehash)
</code></pre>
<p><strong>Purpose</strong>: Get the MetaTransaction struct typehash for EIP-712.</p>
<h4>getMainTypehash</h4>
<pre><code class="language-solidity">function getMainTypehash() external pure returns (bytes32 typehash)
</code></pre>
<p><strong>Purpose</strong>: Get the main typehash for batch meta-transactions.</p>
<h4>getSigningDigest</h4>
<pre><code class="language-solidity">function getSigningDigest(
    address from,
    MetaTransaction[] calldata metaTxs,
    uint256 nonce,
    uint256 deadline
) external view returns (bytes32 digest)
</code></pre>
<p><strong>Purpose</strong>: Helper for frontend to generate the EIP-712 digest for signing.</p>
<h4>getTotalBatchCount</h4>
<pre><code class="language-solidity">function getTotalBatchCount() external view returns (uint256 count)
</code></pre>
<p><strong>Purpose</strong>: Get the total number of batch transactions processed.</p>
<h4>getVersion</h4>
<pre><code class="language-solidity">function getVersion() external pure returns (string memory version)
</code></pre>
<p><strong>Returns</strong>: &quot;v1.0.0-native-token-support&quot;</p>
<h2>Data Structures</h2>
<h3>MetaTransaction</h3>
<pre><code class="language-solidity">struct MetaTransaction {
    address to;        // Target contract address
    uint256 value;     // Native token amount (ETH/BNB)
    bytes data;        // Function call data
}
</code></pre>
<h2>Events</h2>
<h3>RelayerAuthorized</h3>
<pre><code class="language-solidity">event RelayerAuthorized(address indexed relayer, bool authorized);
</code></pre>
<p><strong>Emitted</strong>: When relayer authorization status changes.</p>
<h3>MetaTransactionExecuted</h3>
<pre><code class="language-solidity">event MetaTransactionExecuted(
    address indexed relayer,
    address indexed user,
    address indexed target,
    uint256 value,
    bytes data,
    bool success
);
</code></pre>
<p><strong>Emitted</strong>: For each individual meta-transaction execution.</p>
<h3>NativeTokenUsed</h3>
<pre><code class="language-solidity">event NativeTokenUsed(
    uint256 indexed batchId,
    uint256 totalRequired,
    uint256 totalUsed,
    uint256 refunded
);
</code></pre>
<p><strong>Emitted</strong>: When native tokens are used in meta-transactions, showing usage and refund details.</p>
<h3>PausedWithReason</h3>
<pre><code class="language-solidity">event PausedWithReason(string reason);
</code></pre>
<p><strong>Emitted</strong>: When the contract is paused with a reason.</p>
<h3>TokenRescued</h3>
<pre><code class="language-solidity">event TokenRescued(address indexed token, address indexed to, uint256 amount);
</code></pre>
<p><strong>Emitted</strong>: When tokens are rescued by the owner.</p>
<h2>EIP-712 Implementation</h2>
<h3>Domain Separator</h3>
<pre><code class="language-solidity">EIP712Domain(
    string name,      // &quot;MetaTxGateway&quot;
    string version,   // &quot;1&quot;
    uint256 chainId,  // Network chain ID
    address verifyingContract // Contract address
)
</code></pre>
<h3>MetaTransaction Type</h3>
<pre><code class="language-solidity">MetaTransaction(
    address to,
    uint256 value,
    bytes data
)
</code></pre>
<h3>Batch MetaTransactions Type</h3>
<pre><code class="language-solidity">MetaTransactions(
    address from,
    MetaTransaction[] metaTxs,
    uint256 nonce,
    uint256 deadline
)
</code></pre>
<h3>Signature Generation (Frontend)</h3>
<pre><code class="language-javascript">const domain = {
    name: &#39;MetaTxGateway&#39;,
    version: &#39;1&#39;,
    chainId: await web3.eth.getChainId(),
    verifyingContract: contractAddress
};

const types = {
    MetaTransaction: [
        { name: &#39;to&#39;, type: &#39;address&#39; },
        { name: &#39;value&#39;, type: &#39;uint256&#39; },
        { name: &#39;data&#39;, type: &#39;bytes&#39; }
    ],
    MetaTransactions: [
        { name: &#39;from&#39;, type: &#39;address&#39; },
        { name: &#39;metaTxs&#39;, type: &#39;MetaTransaction[]&#39; },
        { name: &#39;nonce&#39;, type: &#39;uint256&#39; },
        { name: &#39;deadline&#39;, type: &#39;uint256&#39; }
    ]
};

const value = {
    from: userAddress,
    metaTxs: metaTxsArray, // Array of {to, value, data}
    nonce: await contract.getNonce(userAddress),
    deadline: Math.floor(Date.now() / 1000) + 3600 // 1 hour
};

const signature = await signer._signTypedData(domain, types, value);
</code></pre>
<h2>Security Considerations</h2>
<ul>
<li>All addresses are validated for zero address.</li>
<li>Signature recovery is performed safely.</li>
<li>Uses OpenZeppelin&#39;s ReentrancyGuard and Pausable.</li>
<li>Only owner can authorize relayers and upgrades.</li>
<li>Refunds unused native tokens to users.</li>
</ul>
<h2>Integration Examples</h2>
<h3>Basic Meta-Transaction</h3>
<pre><code class="language-javascript">const metaTx = {
    to: tokenContract.address,
    value: 0,
    data: tokenContract.interface.encodeFunctionData(&#39;transfer&#39;, [recipient, amount])
};

const metaTxs = [metaTx];

const requiredValue = await gateway.calculateRequiredValue(metaTxs);

const tx = await gateway.executeMetaTransactions(
    userAddress,
    metaTxs,
    signature,
    nonce,
    deadline,
    { value: requiredValue }
);
</code></pre>
<h3>Native Token Meta-Transaction</h3>
<pre><code class="language-javascript">const metaTx = {
    to: recipientAddress,
    value: ethers.utils.parseEther(&#39;0.1&#39;),
    data: &#39;0x&#39;
};

const metaTxs = [metaTx];

const requiredValue = await gateway.calculateRequiredValue(metaTxs);

const tx = await gateway.executeMetaTransactions(
    userAddress,
    metaTxs,
    signature,
    nonce,
    deadline,
    { value: requiredValue }
);
</code></pre>
<h2>Deployed Contracts</h2>
<ul>
<li><p>MetaTxGateway (deployed)<br>Chains: Mainnet, BSC, Base, Polygon, Optimism, Arbitrum, Avalanche<br>Address: 0xbee9591415128F7d52279C8df327614d8fD8a9b2</p>
</li>
<li><p>GasCreditVault (BSC)<br>Address: 0x0A4467D2D63dB133eC34162Ca0f738948d40A28c</p>
</li>
</ul>
<h2>Next Steps</h2>
<ul>
<li><strong><a href="metatxgateway/native-token-handling.md">Native Token Handling</a></strong> - Deep dive into value validation</li>
<li><strong><a href="metatxgateway/batch-processing.md">Batch Processing</a></strong> - Optimize with batches</li>
<li><strong><a href="metatxgateway/eip-712-signatures.md">EIP-712 Signatures</a></strong> - Signature implementation</li>
<li><strong><a href="../api/metatxgateway-api.md">API Reference</a></strong> - Complete function reference</li>
<li><strong><a href="../tokenomics/di-token.md">DI Token</a></strong> - Token details and governance</li>
<li><strong><a href="../tokenomics/token-presale.md">Token Presale</a></strong> - Presale participation guide</li>
<li><strong><a href="../tokenomics/token-staking.md">Token Staking</a></strong> - Staking and rewards</li>
<li><strong>Vesting schedule</strong> (optional)</li>
<li><strong>Funds forwarding</strong> to treasury</li>
</ul>
<h4>Contract Interface</h4>
<pre><code class="language-solidity">function buyTokens() external payable;
function claimTokens() external;
function setRate(uint256 newRate) external onlyOwner;
function setSaleActive(bool active) external onlyOwner;
function withdrawFunds(address payable to) external onlyOwner;
</code></pre>
<h3>Token Staking</h3>
<p>The Token Staking contract allows users to lock DI tokens and earn rewards. Staking supports flexible or fixed terms, with rewards distributed in DI tokens.</p>
<h4>Key Features</h4>
<ul>
<li><strong>Stake/unstake</strong> at any time (or after lock period)</li>
<li><strong>Reward calculation</strong> based on staked amount and duration</li>
<li><strong>Penalty for early withdrawal</strong> (optional)</li>
<li><strong>View functions</strong> for user and pool stats</li>
</ul>
<h4>Contract Interface</h4>
<pre><code class="language-solidity">function stake(uint256 amount) external;
function unstake(uint256 amount) external;
function claimRewards() external;
function getStaked(address user) external view returns (uint256);
function getPendingRewards(address user) external view returns (uint256);
</code></pre>
<h2>Next Steps</h2>
<ul>
<li><strong><a href="metatxgateway/native-token-handling.md">Native Token Handling</a></strong> - Deep dive into value validation</li>
<li><strong><a href="metatxgateway/batch-processing.md">Batch Processing</a></strong> - Optimize with batches</li>
<li><strong><a href="metatxgateway/eip-712-signatures.md">EIP-712 Signatures</a></strong> - Signature implementation</li>
<li><strong><a href="../api/metatxgateway-api.md">API Reference</a></strong> - Complete function reference</li>
<li><strong><a href="./di-token.md">DI Token</a></strong> - Token details and governance</li>
<li><strong><a href="./token-presale.md">Token Presale</a></strong> - Presale participation guide</li>
<li><strong><a href="./token-staking.md">Token Staking</a></strong> - Staking and rewards</li>
</ul>
<div class="page-break"></div><h1 id="gas-credit-vault">Gas Credit Vault</h1><p>The GasCreditVault is a core component of the MetaTx-Contracts system that manages gas credits backed by ERC-20 tokens. It allows users to deposit supported tokens and receive credits that can be used to pay for meta-transaction fees, eliminating the need to hold native tokens for gas.</p>
<h2>Overview</h2>
<p>The GasCreditVault contract serves as a secure vault for managing user deposits and converting them into gas credits that can be used across the MetaTx ecosystem. It integrates with Chainlink price feeds to ensure fair and accurate conversion rates between different tokens and gas costs.</p>
<h3>Key Features</h3>
<ul>
<li><strong>Multi-Token Support</strong>: Accept multiple ERC-20 tokens as collateral</li>
<li><strong>Chainlink Integration</strong>: Real-time price feeds for accurate conversions  </li>
<li><strong>Credit Management</strong>: Flexible credit allocation, transfer, and usage tracking</li>
<li><strong>Security</strong>: Comprehensive access controls and safety mechanisms</li>
<li><strong>Upgradeable</strong>: UUPS proxy pattern for future improvements</li>
</ul>
<h2>Architecture</h2>
<pre><code class="language-mermaid">flowchart TB
    subgraph &quot;GasCreditVault&quot;
        A[Token Deposits] --&gt; B[Price Conversion]
        B --&gt; C[Credit Allocation]
        C --&gt; D[Credit Management]
        D --&gt; E[Usage Tracking]
    end
    
    subgraph &quot;External Dependencies&quot;
        F[Chainlink Oracles] --&gt; B
        G[ERC-20 Tokens] --&gt; A
        H[MetaTxGateway] --&gt; D
    end
    
    subgraph &quot;User Operations&quot;
        I[Deposit Tokens] --&gt; A
        J[Transfer Credits] --&gt; D
        K[Withdraw Tokens] --&gt; A
        L[Check Balance] --&gt; E
    end
    
</code></pre>
<h2>Contract Interface</h2>
<h3>Core Functions</h3>
<pre><code class="language-solidity">interface IGasCreditVault {
    // Deposit Operations
    function depositCredits(address token, uint256 amount) external;
    function depositCreditsFor(address user, address token, uint256 amount) external;
    
    // Credit Management
    function transferCredits(address to, uint256 amount) external;
    function useCredits(address user, uint256 amount) external;
    
    // Withdrawal Operations
    function withdrawTokens(address token, uint256 amount) external;
    function emergencyWithdraw(address token) external;
    
    // View Functions
    function getCreditBalance(address user) external view returns (uint256);
    function getTokenBalance(address user, address token) external view returns (uint256);
    function getSupportedTokens() external view returns (address[] memory);
    function getTokenPrice(address token) external view returns (uint256);
    
    // Administrative Functions
    function addSupportedToken(address token, address priceFeed) external;
    function removeSupportedToken(address token) external;
    function updateTokenPriceFeed(address token, address priceFeed) external;
    function setPriceSlippageTolerance(uint256 tolerance) external;
}
</code></pre>
<h2>Token Support</h2>
<h3>Supported Tokens</h3>
<p>The vault supports multiple ERC-20 tokens with Chainlink price feeds:</p>
<pre><code class="language-solidity">// Example supported tokens on BSC
struct SupportedToken {
    address token;           // Token contract address
    address priceFeed;      // Chainlink price feed
    uint8 decimals;         // Token decimals
    bool active;            // Whether deposits are active
    uint256 maxDeposit;     // Maximum deposit amount
    uint256 minDeposit;     // Minimum deposit amount
}

mapping(address =&gt; SupportedToken) public supportedTokens;
</code></pre>
<h3>Adding New Tokens</h3>
<p>Only administrators can add new supported tokens:</p>
<pre><code class="language-solidity">function addSupportedToken(
    address token,
    address priceFeed,
    uint256 maxDeposit,
    uint256 minDeposit
) external onlyRole(ADMIN_ROLE) {
    require(token != address(0), &quot;Invalid token&quot;);
    require(priceFeed != address(0), &quot;Invalid price feed&quot;);
    
    supportedTokens[token] = SupportedToken({
        token: token,
        priceFeed: priceFeed,
        decimals: IERC20Metadata(token).decimals(),
        active: true,
        maxDeposit: maxDeposit,
        minDeposit: minDeposit
    });
    
    emit TokenAdded(token, priceFeed);
}
</code></pre>
<h2>Credit Conversion</h2>
<h3>Price Calculation</h3>
<p>Credits are calculated based on real-time token prices from Chainlink:</p>
<pre><code class="language-solidity">function calculateCredits(address token, uint256 amount) 
    public view returns (uint256 credits) {
    
    SupportedToken memory tokenInfo = supportedTokens[token];
    require(tokenInfo.active, &quot;Token not supported&quot;);
    
    // Get latest price from Chainlink
    (, int256 price, , uint256 updatedAt, ) = 
        AggregatorV3Interface(tokenInfo.priceFeed).latestRoundData();
    
    require(price &gt; 0, &quot;Invalid price&quot;);
    require(block.timestamp - updatedAt &lt;= priceStaleThreshold, &quot;Price too old&quot;);
    
    // Convert token amount to USD value
    uint256 usdValue = (amount * uint256(price) * 1e18) / 
        (10 ** (tokenInfo.decimals + 8)); // Chainlink uses 8 decimals
    
    // Convert USD to credits (1 credit = 1 USD cent)
    credits = usdValue / 1e16; // 1e18 / 1e2
}
</code></pre>
<h3>Price Staleness Protection</h3>
<pre><code class="language-solidity">uint256 public constant PRICE_STALE_THRESHOLD = 3600; // 1 hour

modifier validPrice(address token) {
    SupportedToken memory tokenInfo = supportedTokens[token];
    (, , , uint256 updatedAt, ) = 
        AggregatorV3Interface(tokenInfo.priceFeed).latestRoundData();
    
    require(
        block.timestamp - updatedAt &lt;= PRICE_STALE_THRESHOLD,
        &quot;Price feed stale&quot;
    );
    _;
}
</code></pre>
<h2>Deposit Operations</h2>
<h3>Basic Deposit</h3>
<pre><code class="language-solidity">function depositCredits(address token, uint256 amount) 
    external 
    nonReentrant 
    validPrice(token) {
    
    require(amount &gt; 0, &quot;Amount must be positive&quot;);
    SupportedToken memory tokenInfo = supportedTokens[token];
    require(tokenInfo.active, &quot;Token not supported&quot;);
    require(amount &gt;= tokenInfo.minDeposit, &quot;Below minimum deposit&quot;);
    require(amount &lt;= tokenInfo.maxDeposit, &quot;Exceeds maximum deposit&quot;);
    
    // Transfer tokens from user
    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
    
    // Calculate credits
    uint256 credits = calculateCredits(token, amount);
    
    // Update balances
    userCredits[msg.sender] += credits;
    userTokenBalances[msg.sender][token] += amount;
    totalCredits += credits;
    
    emit CreditsDeposited(msg.sender, token, amount, credits);
}
</code></pre>
<h3>Deposit for Another User</h3>
<pre><code class="language-solidity">function depositCreditsFor(address user, address token, uint256 amount) 
    external 
    nonReentrant 
    validPrice(token) {
    
    require(user != address(0), &quot;Invalid user&quot;);
    require(amount &gt; 0, &quot;Amount must be positive&quot;);
    
    SupportedToken memory tokenInfo = supportedTokens[token];
    require(tokenInfo.active, &quot;Token not supported&quot;);
    
    // Transfer tokens from sender
    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
    
    // Calculate credits
    uint256 credits = calculateCredits(token, amount);
    
    // Update balances for target user
    userCredits[user] += credits;
    userTokenBalances[user][token] += amount;
    totalCredits += credits;
    
    emit CreditsDepositedFor(msg.sender, user, token, amount, credits);
}
</code></pre>
<h2>Credit Management</h2>
<h3>Credit Transfer</h3>
<pre><code class="language-solidity">function transferCredits(address to, uint256 amount) 
    external 
    nonReentrant {
    
    require(to != address(0), &quot;Invalid recipient&quot;);
    require(amount &gt; 0, &quot;Amount must be positive&quot;);
    require(userCredits[msg.sender] &gt;= amount, &quot;Insufficient credits&quot;);
    
    userCredits[msg.sender] -= amount;
    userCredits[to] += amount;
    
    emit CreditsTransferred(msg.sender, to, amount);
}
</code></pre>
<h3>Credit Usage</h3>
<pre><code class="language-solidity">function useCredits(address user, uint256 amount) 
    external 
    onlyRole(GATEWAY_ROLE) 
    nonReentrant {
    
    require(amount &gt; 0, &quot;Amount must be positive&quot;);
    require(userCredits[user] &gt;= amount, &quot;Insufficient credits&quot;);
    
    userCredits[user] -= amount;
    totalCreditsUsed += amount;
    
    emit CreditsUsed(user, amount);
}
</code></pre>
<h2>Withdrawal Operations</h2>
<h3>Token Withdrawal</h3>
<pre><code class="language-solidity">function withdrawTokens(address token, uint256 amount) 
    external 
    nonReentrant {
    
    require(amount &gt; 0, &quot;Amount must be positive&quot;);
    require(
        userTokenBalances[msg.sender][token] &gt;= amount,
        &quot;Insufficient token balance&quot;
    );
    
    // Calculate credits to deduct
    uint256 creditsToDeduct = calculateCredits(token, amount);
    require(
        userCredits[msg.sender] &gt;= creditsToDeduct,
        &quot;Insufficient credits for withdrawal&quot;
    );
    
    // Update balances
    userTokenBalances[msg.sender][token] -= amount;
    userCredits[msg.sender] -= creditsToDeduct;
    totalCredits -= creditsToDeduct;
    
    // Transfer tokens
    IERC20(token).safeTransfer(msg.sender, amount);
    
    emit TokensWithdrawn(msg.sender, token, amount, creditsToDeduct);
}
</code></pre>
<h3>Emergency Withdrawal</h3>
<pre><code class="language-solidity">function emergencyWithdraw(address token) 
    external 
    nonReentrant 
    whenPaused {
    
    uint256 amount = userTokenBalances[msg.sender][token];
    require(amount &gt; 0, &quot;No tokens to withdraw&quot;);
    
    // Clear balances without credit calculation
    userTokenBalances[msg.sender][token] = 0;
    userCredits[msg.sender] = 0;
    
    // Transfer tokens
    IERC20(token).safeTransfer(msg.sender, amount);
    
    emit EmergencyWithdrawal(msg.sender, token, amount);
}
</code></pre>
<h2>Security Features</h2>
<h3>Access Control</h3>
<pre><code class="language-solidity">bytes32 public constant ADMIN_ROLE = keccak256(&quot;ADMIN_ROLE&quot;);
bytes32 public constant GATEWAY_ROLE = keccak256(&quot;GATEWAY_ROLE&quot;);
bytes32 public constant OPERATOR_ROLE = keccak256(&quot;OPERATOR_ROLE&quot;);

modifier onlyAdmin() {
    require(hasRole(ADMIN_ROLE, msg.sender), &quot;Not admin&quot;);
    _;
}

modifier onlyGateway() {
    require(hasRole(GATEWAY_ROLE, msg.sender), &quot;Not gateway&quot;);
    _;
}
</code></pre>
<h3>Circuit Breaker</h3>
<pre><code class="language-solidity">contract GasCreditVault is Pausable {
    uint256 public constant MAX_DAILY_WITHDRAWAL = 100000e18; // $100k
    mapping(uint256 =&gt; uint256) public dailyWithdrawals;
    
    modifier withdrawalLimit(uint256 amount) {
        uint256 today = block.timestamp / 1 days;
        require(
            dailyWithdrawals[today] + amount &lt;= MAX_DAILY_WITHDRAWAL,
            &quot;Daily withdrawal limit exceeded&quot;
        );
        dailyWithdrawals[today] += amount;
        _;
    }
    
    function pause() external onlyRole(ADMIN_ROLE) {
        _pause();
    }
    
    function unpause() external onlyRole(ADMIN_ROLE) {
        _unpause();
    }
}
</code></pre>
<h3>Reentrancy Protection</h3>
<pre><code class="language-solidity">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;

contract GasCreditVault is ReentrancyGuard {
    // All state-changing functions use nonReentrant modifier
}
</code></pre>
<h2>Events</h2>
<pre><code class="language-solidity">event CreditsDeposited(
    address indexed user,
    address indexed token,
    uint256 amount,
    uint256 credits
);

event CreditsDepositedFor(
    address indexed depositor,
    address indexed user,
    address indexed token,
    uint256 amount,
    uint256 credits
);

event CreditsTransferred(
    address indexed from,
    address indexed to,
    uint256 amount
);

event CreditsUsed(
    address indexed user,
    uint256 amount
);

event TokensWithdrawn(
    address indexed user,
    address indexed token,
    uint256 amount,
    uint256 creditsDeducted
);

event EmergencyWithdrawal(
    address indexed user,
    address indexed token,
    uint256 amount
);

event TokenAdded(
    address indexed token,
    address indexed priceFeed
);

event TokenRemoved(
    address indexed token
);

event PriceFeedUpdated(
    address indexed token,
    address indexed oldFeed,
    address indexed newFeed
);
</code></pre>
<h2>Error Handling</h2>
<pre><code class="language-solidity">error InsufficientCredits(uint256 required, uint256 available);
error TokenNotSupported(address token);
error PriceFeedStale(address token, uint256 lastUpdate);
error InvalidAmount(uint256 amount);
error ExceedsMaxDeposit(uint256 amount, uint256 maxDeposit);
error BelowMinDeposit(uint256 amount, uint256 minDeposit);
error WithdrawalLimitExceeded(uint256 amount, uint256 limit);
</code></pre>
<h2>Gas Optimization</h2>
<h3>Batch Operations</h3>
<pre><code class="language-solidity">function batchDepositCredits(
    address[] calldata tokens,
    uint256[] calldata amounts
) external nonReentrant {
    require(tokens.length == amounts.length, &quot;Array length mismatch&quot;);
    require(tokens.length &lt;= 10, &quot;Too many tokens&quot;);
    
    uint256 totalCredits = 0;
    
    for (uint256 i = 0; i &lt; tokens.length; i++) {
        address token = tokens[i];
        uint256 amount = amounts[i];
        
        require(amount &gt; 0, &quot;Invalid amount&quot;);
        require(supportedTokens[token].active, &quot;Token not supported&quot;);
        
        // Transfer tokens
        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
        
        // Calculate credits
        uint256 credits = calculateCredits(token, amount);
        totalCredits += credits;
        
        // Update token balance
        userTokenBalances[msg.sender][token] += amount;
        
        emit CreditsDeposited(msg.sender, token, amount, credits);
    }
    
    // Update total credits once
    userCredits[msg.sender] += totalCredits;
    totalCredits += totalCredits;
}
</code></pre>
<h3>Storage Optimization</h3>
<pre><code class="language-solidity">// Pack related data into structs to save storage slots
struct UserData {
    uint128 totalCredits;    // 16 bytes
    uint128 lastActivity;    // 16 bytes
}

mapping(address =&gt; UserData) public userData;
</code></pre>
<h2>Integration Examples</h2>
<h3>Frontend Integration</h3>
<pre><code class="language-javascript">import { ethers } from &#39;ethers&#39;;

class GasCreditVaultClient {
    constructor(contractAddress, provider) {
        this.contract = new ethers.Contract(
            contractAddress,
            GasCreditVaultABI,
            provider
        );
    }
    
    async depositCredits(token, amount, signer) {
        const contract = this.contract.connect(signer);
        
        // First approve the vault to spend tokens
        const tokenContract = new ethers.Contract(token, ERC20_ABI, signer);
        const approveTx = await tokenContract.approve(
            this.contract.address,
            amount
        );
        await approveTx.wait();
        
        // Then deposit
        const depositTx = await contract.depositCredits(token, amount);
        return await depositTx.wait();
    }
    
    async getCreditBalance(user) {
        return await this.contract.getCreditBalance(user);
    }
    
    async getSupportedTokens() {
        return await this.contract.getSupportedTokens();
    }
}
</code></pre>
<h2>Best Practices</h2>
<h3>For Developers</h3>
<ol>
<li><strong>Always check return values</strong> from external calls</li>
<li><strong>Use SafeERC20</strong> for token transfers</li>
<li><strong>Implement proper access controls</strong> for administrative functions</li>
<li><strong>Add circuit breakers</strong> for emergency situations</li>
<li><strong>Monitor price feed staleness</strong> to prevent oracle attacks</li>
</ol>
<h3>For Users</h3>
<ol>
<li><strong>Start with small deposits</strong> to test the system</li>
<li><strong>Monitor your credit balance</strong> regularly</li>
<li><strong>Be aware of price volatility</strong> affecting credit values</li>
<li><strong>Keep some buffer credits</strong> for unexpected gas spikes</li>
<li><strong>Use batch operations</strong> when depositing multiple tokens</li>
</ol>
<h2>Deployed Address</h2>
<ul>
<li>BSC: 0x0A4467D2D63dB133eC34162Ca0f738948d40A28c</li>
</ul>
<hr>
<p><strong>Next Steps</strong>: </p>
<ul>
<li>Learn about <a href="gascreditvault/multi-token-support.md">Multi-Token Support</a></li>
<li>Understand <a href="gascreditvault/chainlink-integration.md">Chainlink Integration</a>  </li>
<li>Explore <a href="gascreditvault/credit-management.md">Credit Management</a></li>
</ul>
<p><strong>Related Contracts</strong>:</p>
<ul>
<li><a href="metatxgateway.md">MetaTxGateway</a> - Uses credits for gas payments</li>
<li><a href="overview.md">Overview</a> - System architecture overview</li>
</ul>
<div class="page-break"></div><h1 id="token-transfers">Token Transfers</h1><p>IU2U Protocol enables seamless token transfers across multiple blockchain networks through a secure burn-and-mint mechanism powered by a decentralized relayer network.</p>
<h2>Overview</h2>
<p>Cross-chain token transfers allow users to move IU2U tokens and other supported assets between different blockchains while maintaining security and decentralization principles.</p>
<h2>Transfer Mechanism</h2>
<h3>Burn-and-Mint Model</h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Source_Gateway as Source Chain Gateway
    participant Token_A as IU2U Token (Chain A)
    participant Relayer as Relayer Network
    participant Token_B as IU2U Token (Chain B)
    participant Dest_Gateway as Destination Chain Gateway
    
    User-&gt;&gt;Source_Gateway: Transfer tokens to Chain B
    Source_Gateway-&gt;&gt;Token_A: Burn tokens
    Token_A-&gt;&gt;Source_Gateway: Emit Burn event
    Source_Gateway-&gt;&gt;Source_Gateway: Emit Transfer event
    
    Relayer-&gt;&gt;Source_Gateway: Monitor Transfer event
    Relayer-&gt;&gt;Relayer: Validate and sign
    Relayer-&gt;&gt;Dest_Gateway: Submit mint command
    Dest_Gateway-&gt;&gt;Token_B: Mint tokens
    Token_B-&gt;&gt;User: Transfer to recipient
    
</code></pre>
<h3>Lock-and-Release Model (For Native Tokens)</h3>
<p>For non-IU2U tokens, the protocol uses a lock-and-release mechanism:</p>
<pre><code class="language-mermaid">flowchart LR
    A[User Deposits Token] --&gt; B[Gateway Locks Token]
    B --&gt; C[Wrapped Token Minted]
    C --&gt; D[Cross-Chain Transfer]
    D --&gt; E[Wrapped Token Burned]
    E --&gt; F[Original Token Released]
</code></pre>
<h2>Implementation</h2>
<h3>Basic Token Transfer</h3>
<pre><code class="language-solidity">interface IIU2UGateway {
    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external;
}
</code></pre>
<h3>Example Usage</h3>
<pre><code class="language-solidity">contract TokenBridge {
    IIU2UGateway public gateway;
    IERC20 public iu2uToken;
    
    function transferToChain(
        string memory targetChain,
        string memory recipient,
        uint256 amount
    ) external {
        // Transfer tokens to gateway
        iu2uToken.transferFrom(msg.sender, address(gateway), amount);
        
        // Initiate cross-chain transfer
        gateway.sendToken(
            targetChain,
            recipient,
            &quot;IU2U&quot;,
            amount
        );
    }
}
</code></pre>
<h3>Advanced Transfer with Data</h3>
<pre><code class="language-solidity">function sendTokenWithData(
    string memory destinationChain,
    string memory destinationAddress,
    string memory symbol,
    uint256 amount,
    bytes memory data
) external {
    // Transfer tokens and execute contract call
    gateway.callContractWithToken(
        destinationChain,
        destinationAddress,
        data,
        symbol,
        amount
    );
}
</code></pre>
<h2>Supported Tokens</h2>
<h3>Native IU2U Token</h3>
<table>
<thead>
<tr>
<th>Chain</th>
<th>Contract Address</th>
<th>Decimals</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>CrossFi</td>
<td><code>0x...</code></td>
<td>18</td>
<td>Native</td>
</tr>
<tr>
<td>Ethereum</td>
<td><code>0x...</code></td>
<td>18</td>
<td>Wrapped</td>
</tr>
<tr>
<td>BSC</td>
<td><code>0x...</code></td>
<td>18</td>
<td>Wrapped</td>
</tr>
<tr>
<td>Polygon</td>
<td><code>0x...</code></td>
<td>18</td>
<td>Wrapped</td>
</tr>
<tr>
<td>Arbitrum</td>
<td><code>0x...</code></td>
<td>18</td>
<td>Wrapped</td>
</tr>
<tr>
<td>Optimism</td>
<td><code>0x...</code></td>
<td>18</td>
<td>Wrapped</td>
</tr>
<tr>
<td>Avalanche</td>
<td><code>0x...</code></td>
<td>18</td>
<td>Wrapped</td>
</tr>
</tbody></table>
<h3>Wrapped Tokens</h3>
<p>The protocol supports wrapping of various tokens for cross-chain transfers:</p>
<pre><code class="language-solidity">struct WrappedToken {
    string symbol;
    uint8 decimals;
    mapping(string =&gt; address) chainAddresses;
    bool isActive;
}

mapping(string =&gt; WrappedToken) public wrappedTokens;
</code></pre>
<h2>Transfer Types</h2>
<h3>1. Simple Transfer</h3>
<p>Direct token transfer between addresses on different chains:</p>
<pre><code class="language-javascript">// Transfer 100 IU2U from Ethereum to BSC
await gateway.sendToken(
    &quot;bsc&quot;,                    // destination chain
    &quot;0x742d35Cc6aB8C...&quot;,    // recipient address
    &quot;IU2U&quot;,                  // token symbol
    ethers.parseEther(&quot;100&quot;) // amount
);
</code></pre>
<h3>2. Transfer with Contract Call</h3>
<p>Transfer tokens and execute a function on the destination chain:</p>
<pre><code class="language-javascript">// Transfer tokens and stake them on destination chain
const stakePayload = ethers.AbiCoder.defaultAbiCoder().encode(
    [&quot;address&quot;, &quot;uint256&quot;],
    [userAddress, stakingPeriod]
);

await gateway.callContractWithToken(
    &quot;polygon&quot;,               // destination chain
    stakingContractAddress,  // staking contract
    stakePayload,           // function call data
    &quot;IU2U&quot;,                 // token symbol
    ethers.parseEther(&quot;500&quot;) // amount to stake
);
</code></pre>
<h3>3. Batch Transfers</h3>
<p>Transfer multiple tokens in a single transaction:</p>
<pre><code class="language-solidity">struct TokenTransfer {
    string destinationChain;
    string destinationAddress;
    string symbol;
    uint256 amount;
}

function batchTransfer(TokenTransfer[] memory transfers) external {
    for (uint256 i = 0; i &lt; transfers.length; i++) {
        sendToken(
            transfers[i].destinationChain,
            transfers[i].destinationAddress,
            transfers[i].symbol,
            transfers[i].amount
        );
    }
}
</code></pre>
<h2>Security Features</h2>
<h3>Multi-Signature Validation</h3>
<p>All token transfers require validation from multiple relayers:</p>
<pre><code class="language-solidity">struct MintCommand {
    bytes32 commandId;
    string sourceChain;
    address recipient;
    uint256 amount;
    bytes32[] signatures;
}

function validateMintCommand(MintCommand memory cmd) internal view returns (bool) {
    require(cmd.signatures.length &gt;= minSignatures, &quot;Insufficient signatures&quot;);
    
    bytes32 hash = keccak256(abi.encode(cmd.commandId, cmd.sourceChain, cmd.recipient, cmd.amount));
    
    uint256 validSignatures = 0;
    for (uint256 i = 0; i &lt; cmd.signatures.length; i++) {
        if (_verifyRelayerSignature(hash, cmd.signatures[i])) {
            validSignatures++;
        }
    }
    
    return validSignatures &gt;= minSignatures;
}
</code></pre>
<h3>Rate Limiting</h3>
<p>Transfer limits prevent large-scale attacks:</p>
<pre><code class="language-solidity">mapping(address =&gt; uint256) public dailyTransferred;
mapping(address =&gt; uint256) public lastTransferDay;

uint256 public dailyLimit = 10000 ether;

modifier rateLimited(uint256 amount) {
    uint256 today = block.timestamp / 1 days;
    
    if (lastTransferDay[msg.sender] &lt; today) {
        dailyTransferred[msg.sender] = 0;
        lastTransferDay[msg.sender] = today;
    }
    
    require(
        dailyTransferred[msg.sender] + amount &lt;= dailyLimit,
        &quot;Daily limit exceeded&quot;
    );
    
    dailyTransferred[msg.sender] += amount;
    _;
}
</code></pre>
<h3>Replay Protection</h3>
<p>Command IDs prevent duplicate token minting:</p>
<pre><code class="language-solidity">mapping(bytes32 =&gt; bool) public executedCommands;

function mint(
    bytes32 commandId,
    address recipient,
    uint256 amount
) external onlyRelayer {
    require(!executedCommands[commandId], &quot;Command already executed&quot;);
    executedCommands[commandId] = true;
    
    _mint(recipient, amount);
}
</code></pre>
<h2>Fee Structure</h2>
<h3>Transfer Fees</h3>
<pre><code class="language-solidity">struct TransferFees {
    uint256 baseFee;          // Fixed fee per transfer
    uint256 percentageFee;    // Percentage of transfer amount
    uint256 gasReimbursement; // Estimated gas cost
}

mapping(string =&gt; TransferFees) public chainFees;
</code></pre>
<h3>Fee Calculation</h3>
<pre><code class="language-solidity">function calculateTransferFee(
    string memory destinationChain,
    uint256 amount
) public view returns (uint256) {
    TransferFees memory fees = chainFees[destinationChain];
    
    uint256 percentageFee = (amount * fees.percentageFee) / 10000;
    return fees.baseFee + percentageFee + fees.gasReimbursement;
}
</code></pre>
<h3>Fee Payment Options</h3>
<ol>
<li><strong>Native Token</strong>: Pay fees in the source chain&#39;s native token</li>
<li><strong>IU2U Token</strong>: Pay fees using IU2U tokens</li>
<li><strong>Deducted from Transfer</strong>: Fees deducted from transfer amount</li>
</ol>
<h2>Gas Management</h2>
<h3>Gas Estimation</h3>
<pre><code class="language-solidity">function estimateTransferGas(
    string memory destinationChain,
    string memory symbol,
    uint256 amount
) external view returns (uint256) {
    // Base gas for token minting
    uint256 baseGas = 50000;
    
    // Additional gas for complex tokens
    if (wrappedTokens[symbol].isActive) {
        baseGas += 30000;
    }
    
    // Chain-specific gas adjustments
    uint256 chainMultiplier = chainGasMultipliers[destinationChain];
    return (baseGas * chainMultiplier) / 100;
}
</code></pre>
<h3>Gas Payment Models</h3>
<h4>Prepaid Gas</h4>
<pre><code class="language-solidity">function transferWithGas(
    string memory destinationChain,
    string memory destinationAddress,
    string memory symbol,
    uint256 amount,
    uint256 gasLimit
) external payable {
    uint256 gasCost = calculateGasCost(destinationChain, gasLimit);
    require(msg.value &gt;= gasCost, &quot;Insufficient gas payment&quot;);
    
    // Process transfer with guaranteed gas
    _sendTokenWithGas(destinationChain, destinationAddress, symbol, amount, gasLimit);
}
</code></pre>
<h4>Token-Based Gas</h4>
<pre><code class="language-solidity">function transferWithTokenGas(
    string memory destinationChain,
    string memory destinationAddress,
    string memory symbol,
    uint256 amount,
    uint256 gasTokenAmount
) external {
    // Deduct gas tokens
    iu2uToken.transferFrom(msg.sender, gasVault, gasTokenAmount);
    
    // Process transfer
    sendToken(destinationChain, destinationAddress, symbol, amount);
}
</code></pre>
<h2>Error Handling</h2>
<h3>Transfer Failures</h3>
<pre><code class="language-solidity">event TransferFailed(
    bytes32 indexed transferId,
    string reason,
    bool canRetry
);

function retryTransfer(bytes32 transferId) external {
    TransferData memory transfer = failedTransfers[transferId];
    require(transfer.canRetry, &quot;Transfer cannot be retried&quot;);
    require(block.timestamp &gt;= transfer.retryAfter, &quot;Too early to retry&quot;);
    
    // Retry the transfer
    _executeTransfer(transfer);
}
</code></pre>
<h3>Automatic Rollback</h3>
<pre><code class="language-solidity">function rollbackTransfer(bytes32 transferId) external onlyRelayer {
    TransferData memory transfer = pendingTransfers[transferId];
    require(transfer.deadline &lt; block.timestamp, &quot;Transfer not expired&quot;);
    
    // Mint tokens back to original sender
    _mint(transfer.sender, transfer.amount);
    
    emit TransferRolledBack(transferId, transfer.sender, transfer.amount);
}
</code></pre>
<h2>Advanced Features</h2>
<h3>Scheduled Transfers</h3>
<pre><code class="language-solidity">struct ScheduledTransfer {
    address sender;
    string destinationChain;
    string destinationAddress;
    string symbol;
    uint256 amount;
    uint256 executeAt;
    bool executed;
}

mapping(bytes32 =&gt; ScheduledTransfer) public scheduledTransfers;

function scheduleTransfer(
    string memory destinationChain,
    string memory destinationAddress,
    string memory symbol,
    uint256 amount,
    uint256 executeAt
) external returns (bytes32) {
    require(executeAt &gt; block.timestamp, &quot;Invalid execution time&quot;);
    
    bytes32 transferId = keccak256(abi.encode(
        msg.sender,
        destinationChain,
        destinationAddress,
        symbol,
        amount,
        executeAt,
        block.number
    ));
    
    scheduledTransfers[transferId] = ScheduledTransfer({
        sender: msg.sender,
        destinationChain: destinationChain,
        destinationAddress: destinationAddress,
        symbol: symbol,
        amount: amount,
        executeAt: executeAt,
        executed: false
    });
    
    return transferId;
}
</code></pre>
<h3>Conditional Transfers</h3>
<pre><code class="language-solidity">function transferOnCondition(
    string memory destinationChain,
    string memory destinationAddress,
    string memory symbol,
    uint256 amount,
    bytes memory condition
) external {
    bytes32 transferId = _generateTransferId();
    
    conditionalTransfers[transferId] = ConditionalTransfer({
        sender: msg.sender,
        destinationChain: destinationChain,
        destinationAddress: destinationAddress,
        symbol: symbol,
        amount: amount,
        condition: condition,
        validated: false
    });
    
    // Lock tokens until condition is met
    _lockTokens(msg.sender, symbol, amount);
}
</code></pre>
<h2>Monitoring and Analytics</h2>
<h3>Transfer Tracking</h3>
<pre><code class="language-solidity">event TokenTransferInitiated(
    bytes32 indexed transferId,
    address indexed sender,
    string indexed destinationChain,
    string destinationAddress,
    string symbol,
    uint256 amount
);

event TokenTransferCompleted(
    bytes32 indexed transferId,
    string indexed sourceChain,
    address indexed recipient,
    string symbol,
    uint256 amount
);
</code></pre>
<h3>Transfer Status</h3>
<pre><code class="language-solidity">enum TransferStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED,
    CANCELLED
}

function getTransferStatus(bytes32 transferId) external view returns (TransferStatus) {
    return transferStatuses[transferId];
}
</code></pre>
<h2>Integration Examples</h2>
<h3>DeFi Integration</h3>
<pre><code class="language-solidity">contract CrossChainYieldFarm {
    function depositAcrossChains(
        string memory sourceChain,
        uint256 amount
    ) external {
        bytes memory depositData = abi.encodeWithSignature(
            &quot;deposit(address,uint256)&quot;,
            msg.sender,
            amount
        );
        
        gateway.callContractWithToken(
            sourceChain,
            address(this),
            depositData,
            &quot;IU2U&quot;,
            amount
        );
    }
    
    function executeWithToken(
        bytes32,
        string memory,
        string memory,
        bytes memory payload,
        string memory,
        uint256 amount
    ) external override onlyGateway {
        (address user, uint256 depositAmount) = abi.decode(
            payload,
            (address, uint256)
        );
        
        require(amount == depositAmount, &quot;Amount mismatch&quot;);
        _deposit(user, amount);
    }
}
</code></pre>
<h3>Gaming Integration</h3>
<pre><code class="language-solidity">contract CrossChainGameAssets {
    function transferAssetToChain(
        uint256 assetId,
        string memory targetChain,
        address newOwner
    ) external {
        require(ownerOf(assetId) == msg.sender, &quot;Not asset owner&quot;);
        
        // Burn asset on current chain
        _burn(assetId);
        
        bytes memory mintData = abi.encodeWithSignature(
            &quot;mintAsset(address,uint256)&quot;,
            newOwner,
            assetId
        );
        
        gateway.callContract(targetChain, address(this), mintData);
    }
}
</code></pre>
<h2>Best Practices</h2>
<h3>For Users</h3>
<ol>
<li><strong>Verify Addresses</strong>: Double-check destination addresses and chains</li>
<li><strong>Check Fees</strong>: Understand fee structure before transferring</li>
<li><strong>Monitor Status</strong>: Track transfer status until completion</li>
<li><strong>Use Proper Gas</strong>: Provide adequate gas for complex transfers</li>
</ol>
<h3>For Developers</h3>
<ol>
<li><strong>Implement Timeouts</strong>: Set reasonable timeouts for transfers</li>
<li><strong>Handle Failures</strong>: Implement proper error handling and recovery</li>
<li><strong>Test Thoroughly</strong>: Test transfers on all supported chains</li>
<li><strong>Monitor Events</strong>: Listen for transfer events and status updates</li>
</ol>
<h3>Security Guidelines</h3>
<ol>
<li><strong>Validate Inputs</strong>: Always validate transfer parameters</li>
<li><strong>Rate Limiting</strong>: Implement appropriate rate limiting</li>
<li><strong>Access Control</strong>: Restrict sensitive functions properly</li>
<li><strong>Audit Regularly</strong>: Regular security audits for transfer logic</li>
</ol>
<h2>Resources</h2>
<ul>
<li><a href="../core-concepts/cross-chain-architecture.md">Cross-Chain Architecture</a></li>
<li><a href="message-passing.md">Message Passing</a></li>
<li><a href="../core-concepts/iu2u-token.md">IU2U Token Details</a></li>
<li><a href="../examples/cross-chain-swap.md">Integration Examples</a></li>
</ul>
<div class="page-break"></div><h1 id="supported-dex-protocols">Supported DEX Protocols</h1><p>The IU2U Protocol integrates with a comprehensive list of decentralized exchanges across multiple blockchains to provide optimal liquidity aggregation and routing. This document outlines all supported DEXes, their capabilities, and integration details.</p>
<h2>Multi-Chain DEX Support</h2>
<h3>Ethereum Mainnet</h3>
<h4>Automated Market Makers (AMMs)</h4>
<p><strong>Uniswap V2 &amp; V3</strong></p>
<ul>
<li><strong>Type</strong>: Concentrated Liquidity (V3), Constant Product (V2)</li>
<li><strong>Fees</strong>: 0.05%, 0.3%, 1% (V3); 0.3% (V2)</li>
<li><strong>Liquidity</strong>: Highest on Ethereum</li>
<li><strong>Integration</strong>: Native support with optimized routing</li>
<li><strong>Special Features</strong>: Multiple fee tiers, concentrated liquidity positions</li>
</ul>
<p><strong>SushiSwap V2 &amp; V3</strong></p>
<ul>
<li><strong>Type</strong>: Fork of Uniswap with additional features</li>
<li><strong>Fees</strong>: 0.25%, 0.3%, 1%</li>
<li><strong>Liquidity</strong>: High across diverse token pairs</li>
<li><strong>Integration</strong>: Full routing and aggregation support</li>
<li><strong>Special Features</strong>: Onsen rewards, cross-chain bridges</li>
</ul>
<p><strong>Curve Finance</strong></p>
<ul>
<li><strong>Type</strong>: Stablecoin and similar-asset optimized AMM</li>
<li><strong>Fees</strong>: 0.04% - 0.4%</li>
<li><strong>Liquidity</strong>: Dominant for stablecoin swaps</li>
<li><strong>Integration</strong>: Custom routing for stable assets</li>
<li><strong>Special Features</strong>: Low slippage for correlated assets</li>
</ul>
<p><strong>Balancer V2</strong></p>
<ul>
<li><strong>Type</strong>: Weighted pools, stable pools, boosted pools</li>
<li><strong>Fees</strong>: Variable (0.01% - 10%)</li>
<li><strong>Liquidity</strong>: Multi-token pools with custom weights</li>
<li><strong>Integration</strong>: Advanced pool types support</li>
<li><strong>Special Features</strong>: Weighted pools, flash loans</li>
</ul>
<h4>Aggregators &amp; Advanced Protocols</h4>
<p><strong>1inch V5</strong></p>
<ul>
<li><strong>Type</strong>: DEX aggregator</li>
<li><strong>Integration</strong>: Secondary aggregation for complex routes</li>
<li><strong>Features</strong>: Chi gas tokens, partial fill protection</li>
<li><strong>Use Case</strong>: Backup routing and validation</li>
</ul>
<p><strong>0x Protocol</strong></p>
<ul>
<li><strong>Type</strong>: Order book + AMM hybrid</li>
<li><strong>Integration</strong>: RFQ and on-chain liquidity</li>
<li><strong>Features</strong>: Professional market makers</li>
<li><strong>Use Case</strong>: Large trades and institutional flows</li>
</ul>
<p><strong>Kyber Network</strong></p>
<ul>
<li><strong>Type</strong>: On-chain liquidity protocol</li>
<li><strong>Integration</strong>: Dynamic market maker support</li>
<li><strong>Features</strong>: Amplified liquidity, elastic supply</li>
<li><strong>Use Case</strong>: Alternative routing for specific pairs</li>
</ul>
<h3>Polygon</h3>
<p><strong>QuickSwap</strong></p>
<ul>
<li><strong>Type</strong>: Uniswap V3 fork with concentrated liquidity</li>
<li><strong>Fees</strong>: 0.01%, 0.05%, 0.3%, 1%</li>
<li><strong>Liquidity</strong>: Leading DEX on Polygon</li>
<li><strong>Integration</strong>: Full V3 routing support</li>
<li><strong>Special Features</strong>: Dragon&#39;s lair staking, perps</li>
</ul>
<p><strong>SushiSwap</strong></p>
<ul>
<li><strong>Type</strong>: Multi-chain AMM deployment</li>
<li><strong>Fees</strong>: 0.25%, 0.3%</li>
<li><strong>Integration</strong>: Cross-chain liquidity access</li>
<li><strong>Features</strong>: Onsen incentives</li>
</ul>
<p><strong>Curve (Polygon)</strong></p>
<ul>
<li><strong>Type</strong>: Stablecoin-optimized pools</li>
<li><strong>Fees</strong>: 0.04% - 0.4%</li>
<li><strong>Integration</strong>: Polygon-specific stable routing</li>
<li><strong>Features</strong>: Cross-chain gauge voting</li>
</ul>
<h3>Binance Smart Chain</h3>
<p><strong>PancakeSwap V2 &amp; V3</strong></p>
<ul>
<li><strong>Type</strong>: Leading BSC AMM with V3 concentrated liquidity</li>
<li><strong>Fees</strong>: 0.01%, 0.05%, 0.25%, 1% (V3); 0.25% (V2)</li>
<li><strong>Liquidity</strong>: Highest on BSC</li>
<li><strong>Integration</strong>: Full V2/V3 support with CAKE farms</li>
<li><strong>Special Features</strong>: Syrup pools, lottery, prediction markets</li>
</ul>
<p><strong>Thena</strong></p>
<ul>
<li><strong>Type</strong>: Solidly fork with ve(3,3) mechanics</li>
<li><strong>Fees</strong>: Variable based on volatility</li>
<li><strong>Integration</strong>: Stable and volatile pair optimization</li>
<li><strong>Features</strong>: Vote-escrowed tokenomics</li>
</ul>
<p><strong>Apeswap</strong></p>
<ul>
<li><strong>Type</strong>: Community-driven AMM</li>
<li><strong>Fees</strong>: 0.2% - 0.3%</li>
<li><strong>Integration</strong>: Alternative routing option</li>
<li><strong>Features</strong>: Jungle farms, lending</li>
</ul>
<p><strong>Biswap</strong></p>
<ul>
<li><strong>Type</strong>: Multi-chain AMM with low fees</li>
<li><strong>Fees</strong>: 0.1% - 0.2%</li>
<li><strong>Integration</strong>: Cost-effective routing</li>
<li><strong>Features</strong>: Launchpads, lottery</li>
</ul>
<h3>Arbitrum</h3>
<p><strong>Uniswap V3</strong></p>
<ul>
<li><strong>Type</strong>: Native V3 deployment</li>
<li><strong>Fees</strong>: 0.05%, 0.3%, 1%</li>
<li><strong>Liquidity</strong>: Primary liquidity source on Arbitrum</li>
<li><strong>Integration</strong>: Full concentrated liquidity support</li>
<li><strong>Features</strong>: L2 cost efficiency</li>
</ul>
<p><strong>SushiSwap</strong></p>
<ul>
<li><strong>Type</strong>: Cross-chain AMM deployment</li>
<li><strong>Fees</strong>: 0.25%, 0.3%</li>
<li><strong>Integration</strong>: Multi-chain liquidity access</li>
<li><strong>Features</strong>: Reduced gas costs</li>
</ul>
<p><strong>Camelot</strong></p>
<ul>
<li><strong>Type</strong>: Native Arbitrum AMM with advanced features</li>
<li><strong>Fees</strong>: Dynamic fees based on volatility</li>
<li><strong>Integration</strong>: Specialized Arbitrum routing</li>
<li><strong>Features</strong>: Nitro pools, escrowed tokens</li>
</ul>
<p><strong>Ramses</strong></p>
<ul>
<li><strong>Type</strong>: Uniswap V3 fork with ve(3,3) mechanics</li>
<li><strong>Fees</strong>: 0.01%, 0.05%, 0.3%, 1%</li>
<li><strong>Integration</strong>: Optimized for Arbitrum ecosystem</li>
<li><strong>Features</strong>: Voter rewards, gauge system</li>
</ul>
<p><strong>GMX</strong></p>
<ul>
<li><strong>Type</strong>: Perpetual exchange with spot swaps</li>
<li><strong>Fees</strong>: 0.2% - 0.8%</li>
<li><strong>Integration</strong>: Large trade execution</li>
<li><strong>Features</strong>: Zero slippage for supported assets</li>
</ul>
<p><strong>Zyberswap</strong></p>
<ul>
<li><strong>Type</strong>: Community-focused AMM</li>
<li><strong>Fees</strong>: 0.25% - 0.3%</li>
<li><strong>Integration</strong>: Alternative routing</li>
<li><strong>Features</strong>: Social trading features</li>
</ul>
<h3>Optimism</h3>
<p><strong>Uniswap V3</strong></p>
<ul>
<li><strong>Type</strong>: Native V3 concentrated liquidity</li>
<li><strong>Fees</strong>: 0.05%, 0.3%, 1%</li>
<li><strong>Liquidity</strong>: Primary OP liquidity</li>
<li><strong>Integration</strong>: Full L2 optimization</li>
<li><strong>Features</strong>: Cheap transactions, fast finality</li>
</ul>
<p><strong>Beethoven X</strong></p>
<ul>
<li><strong>Type</strong>: Balancer V2 fork</li>
<li><strong>Fees</strong>: Variable pool fees</li>
<li><strong>Integration</strong>: Weighted and stable pools</li>
<li><strong>Features</strong>: Boosted pools, yield farming</li>
</ul>
<p><strong>Velodrome</strong></p>
<ul>
<li><strong>Type</strong>: Solidly fork with ve(3,3) mechanics</li>
<li><strong>Fees</strong>: Dynamic based on pair type</li>
<li><strong>Integration</strong>: Optimized stable/volatile routing</li>
<li><strong>Features</strong>: Vote-escrowed VELO, bribes</li>
</ul>
<h3>Avalanche</h3>
<p><strong>Trader Joe V2</strong></p>
<ul>
<li><strong>Type</strong>: Concentrated liquidity with bins</li>
<li><strong>Fees</strong>: Variable bin-based pricing</li>
<li><strong>Integration</strong>: Liquidity book protocol support</li>
<li><strong>Features</strong>: Zero slippage swaps in active bin</li>
</ul>
<p><strong>Platypus Finance</strong></p>
<ul>
<li><strong>Type</strong>: Single-sided stablecoin AMM</li>
<li><strong>Fees</strong>: 0.1% - 0.3%</li>
<li><strong>Integration</strong>: Stable asset optimization</li>
<li><strong>Features</strong>: Single-sided liquidity, coverage ratio</li>
</ul>
<p><strong>Pangolin</strong></p>
<ul>
<li><strong>Type</strong>: Uniswap V2 fork</li>
<li><strong>Fees</strong>: 0.3%</li>
<li><strong>Integration</strong>: Basic AMM routing</li>
<li><strong>Features</strong>: AVAX ecosystem integration</li>
</ul>
<p><strong>SushiSwap</strong></p>
<ul>
<li><strong>Type</strong>: Multi-chain deployment</li>
<li><strong>Fees</strong>: 0.25% - 0.3%</li>
<li><strong>Integration</strong>: Cross-chain liquidity</li>
<li><strong>Features</strong>: Avalanche-specific incentives</li>
</ul>
<h3>Fantom</h3>
<p><strong>SpookySwap</strong></p>
<ul>
<li><strong>Type</strong>: Native Fantom AMM</li>
<li><strong>Fees</strong>: 0.2% - 0.3%</li>
<li><strong>Integration</strong>: Fantom ecosystem optimization</li>
<li><strong>Features</strong>: BOO staking, farms</li>
</ul>
<p><strong>SpiritSwap</strong></p>
<ul>
<li><strong>Type</strong>: Solidly-based ve(3,3) AMM</li>
<li><strong>Fees</strong>: Variable based on pair type</li>
<li><strong>Integration</strong>: Stable/volatile optimization</li>
<li><strong>Features</strong>: SPIRIT incentives, gauges</li>
</ul>
<p><strong>Beethoven X</strong></p>
<ul>
<li><strong>Type</strong>: Balancer V2 fork for Fantom</li>
<li><strong>Fees</strong>: Variable pool fees</li>
<li><strong>Integration</strong>: Weighted pools support</li>
<li><strong>Features</strong>: Fantom-specific incentives</li>
</ul>
<h3>Base</h3>
<p><strong>Uniswap V3</strong></p>
<ul>
<li><strong>Type</strong>: Native Coinbase L2 deployment</li>
<li><strong>Fees</strong>: 0.05%, 0.3%, 1%</li>
<li><strong>Integration</strong>: Full Base ecosystem support</li>
<li><strong>Features</strong>: Low-cost transactions</li>
</ul>
<p><strong>Aerodrome</strong></p>
<ul>
<li><strong>Type</strong>: Velodrome fork for Base</li>
<li><strong>Fees</strong>: Dynamic ve(3,3) model</li>
<li><strong>Integration</strong>: Base-native routing</li>
<li><strong>Features</strong>: AERO tokenomics</li>
</ul>
<h3>Layer 2 &amp; Sidechains</h3>
<p><strong>xDAI/Gnosis Chain</strong></p>
<ul>
<li><strong>SushiSwap</strong>: Cross-chain AMM</li>
<li><strong>Curve</strong>: Stablecoin optimization</li>
<li><strong>Balancer</strong>: Multi-asset pools</li>
</ul>
<p><strong>Moonbeam</strong></p>
<ul>
<li><strong>SushiSwap</strong>: Polkadot ecosystem bridge</li>
<li><strong>Curve</strong>: Cross-chain stable swaps</li>
</ul>
<h2>Integration Architecture</h2>
<h3>Router Classification</h3>
<pre><code class="language-solidity">enum RouterType {
    UNISWAP_V2,      // Constant product AMM
    UNISWAP_V3,      // Concentrated liquidity
    CURVE,           // Stable asset AMM
    BALANCER,        // Weighted pools
    SOLIDLY,         // ve(3,3) mechanics
    AGGREGATOR,      // Meta-aggregators
    ORDERBOOK,       // Order book DEXes
    HYBRID           // Mixed models
}
</code></pre>
<h3>Liquidity Detection</h3>
<pre><code class="language-javascript">class LiquidityDetector {
    constructor() {
        this.dexRegistry = new Map();
        this.poolCache = new Map();
        this.lastUpdate = new Map();
    }

    async detectAvailableLiquidity(tokenA, tokenB, chainId) {
        const dexes = this.dexRegistry.get(chainId) || [];
        const liquiditySources = [];

        for (const dex of dexes) {
            try {
                const liquidity = await this.checkDEXLiquidity(dex, tokenA, tokenB);
                if (liquidity.available) {
                    liquiditySources.push({
                        dex: dex.name,
                        type: dex.type,
                        liquidity: liquidity.amount,
                        fees: liquidity.fees,
                        slippage: liquidity.estimatedSlippage
                    });
                }
            } catch (error) {
                console.warn(`Failed to check ${dex.name}:`, error);
            }
        }

        return liquiditySources.sort((a, b) =&gt; b.liquidity - a.liquidity);
    }

    async checkDEXLiquidity(dex, tokenA, tokenB) {
        switch (dex.type) {
            case &#39;UNISWAP_V2&#39;:
                return this.checkUniswapV2Liquidity(dex, tokenA, tokenB);
            case &#39;UNISWAP_V3&#39;:
                return this.checkUniswapV3Liquidity(dex, tokenA, tokenB);
            case &#39;CURVE&#39;:
                return this.checkCurveLiquidity(dex, tokenA, tokenB);
            case &#39;BALANCER&#39;:
                return this.checkBalancerLiquidity(dex, tokenA, tokenB);
            default:
                return { available: false };
        }
    }

    async checkUniswapV2Liquidity(dex, tokenA, tokenB) {
        const pairAddress = await this.getUniswapV2Pair(dex.factory, tokenA, tokenB);
        if (pairAddress === ethers.ZeroAddress) {
            return { available: false };
        }

        const pairContract = new ethers.Contract(pairAddress, PAIR_ABI, provider);
        const reserves = await pairContract.getReserves();
        
        return {
            available: true,
            amount: Math.min(Number(reserves.reserve0), Number(reserves.reserve1)),
            fees: 0.003, // 0.3%
            estimatedSlippage: this.estimateV2Slippage(reserves, tokenA, tokenB)
        };
    }

    async checkUniswapV3Liquidity(dex, tokenA, tokenB) {
        const feeTiers = [100, 500, 3000, 10000]; // 0.01%, 0.05%, 0.3%, 1%
        let bestLiquidity = { available: false };

        for (const fee of feeTiers) {
            try {
                const poolAddress = await this.getUniswapV3Pool(dex.factory, tokenA, tokenB, fee);
                if (poolAddress !== ethers.ZeroAddress) {
                    const poolContract = new ethers.Contract(poolAddress, POOL_V3_ABI, provider);
                    const liquidity = await poolContract.liquidity();
                    
                    if (Number(liquidity) &gt; (bestLiquidity.amount || 0)) {
                        bestLiquidity = {
                            available: true,
                            amount: Number(liquidity),
                            fees: fee / 10000,
                            feeTier: fee,
                            estimatedSlippage: this.estimateV3Slippage(liquidity, fee)
                        };
                    }
                }
            } catch (error) {
                // Pool doesn&#39;t exist for this fee tier
                continue;
            }
        }

        return bestLiquidity;
    }

    async checkCurveLiquidity(dex, tokenA, tokenB) {
        // Check Curve registry for available pools
        const registry = new ethers.Contract(dex.registry, CURVE_REGISTRY_ABI, provider);
        
        try {
            const poolAddress = await registry.find_pool_for_coins(tokenA, tokenB);
            if (poolAddress === ethers.ZeroAddress) {
                return { available: false };
            }

            const poolContract = new ethers.Contract(poolAddress, CURVE_POOL_ABI, provider);
            const balances = await poolContract.get_balances();
            
            return {
                available: true,
                amount: Math.min(...balances.map(b =&gt; Number(b))),
                fees: 0.0004, // Typical Curve fee
                poolType: &#39;stable&#39;,
                estimatedSlippage: this.estimateCurveSlippage(balances)
            };
        } catch (error) {
            return { available: false };
        }
    }

    async checkBalancerLiquidity(dex, tokenA, tokenB) {
        // Query Balancer subgraph for pools containing both tokens
        const query = `
            query {
                pools(
                    where: {
                        tokensList_contains: [&quot;${tokenA.toLowerCase()}&quot;, &quot;${tokenB.toLowerCase()}&quot;]
                    }
                    orderBy: totalLiquidity
                    orderDirection: desc
                    first: 5
                ) {
                    id
                    totalLiquidity
                    swapFee
                    poolType
                    tokens {
                        address
                        balance
                        weight
                    }
                }
            }
        `;

        try {
            const response = await this.querySubgraph(dex.subgraphUrl, query);
            const pools = response.data.pools;

            if (pools.length === 0) {
                return { available: false };
            }

            const bestPool = pools[0];
            return {
                available: true,
                amount: Number(bestPool.totalLiquidity),
                fees: Number(bestPool.swapFee),
                poolId: bestPool.id,
                poolType: bestPool.poolType,
                estimatedSlippage: this.estimateBalancerSlippage(bestPool)
            };
        } catch (error) {
            return { available: false };
        }
    }

    estimateV2Slippage(reserves, tokenA, tokenB) {
        // Simplified slippage estimation for demonstration
        const reserve0 = Number(reserves.reserve0);
        const reserve1 = Number(reserves.reserve1);
        const minReserve = Math.min(reserve0, reserve1);
        
        // Lower liquidity = higher slippage
        if (minReserve &lt; 1000) return 0.05; // 5%
        if (minReserve &lt; 10000) return 0.02; // 2%
        if (minReserve &lt; 100000) return 0.01; // 1%
        return 0.005; // 0.5%
    }

    estimateV3Slippage(liquidity, feeTier) {
        // V3 slippage depends on concentrated liquidity and fee tier
        const liquidityNum = Number(liquidity);
        const baseFee = feeTier / 10000;
        
        if (liquidityNum &lt; 1000) return baseFee * 10;
        if (liquidityNum &lt; 10000) return baseFee * 5;
        if (liquidityNum &lt; 100000) return baseFee * 2;
        return baseFee;
    }

    estimateCurveSlippage(balances) {
        // Curve has very low slippage for stable assets
        const minBalance = Math.min(...balances.map(b =&gt; Number(b)));
        
        if (minBalance &lt; 1000) return 0.02; // 2%
        if (minBalance &lt; 10000) return 0.005; // 0.5%
        return 0.001; // 0.1%
    }

    estimateBalancerSlippage(pool) {
        const totalLiquidity = Number(pool.totalLiquidity);
        
        if (totalLiquidity &lt; 10000) return 0.03; // 3%
        if (totalLiquidity &lt; 100000) return 0.01; // 1%
        return 0.005; // 0.5%
    }

    async querySubgraph(url, query) {
        const response = await fetch(url, {
            method: &#39;POST&#39;,
            headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
            body: JSON.stringify({ query })
        });
        return await response.json();
    }
}
</code></pre>
<h2>DEX-Specific Optimizations</h2>
<h3>Curve Finance Integration</h3>
<p>Curve requires special handling for stable asset swaps:</p>
<pre><code class="language-javascript">class CurveOptimizer {
    async getOptimalCurveRoute(tokenIn, tokenOut, amountIn) {
        // Check for direct pools first
        const directPool = await this.findDirectPool(tokenIn, tokenOut);
        if (directPool) {
            return {
                pools: [directPool],
                route: [tokenIn, tokenOut],
                expectedOutput: await this.quoteCurveSwap(directPool, tokenIn, tokenOut, amountIn)
            };
        }

        // Check for meta pools (pools that contain other pools)
        const metaRoute = await this.findMetaPoolRoute(tokenIn, tokenOut);
        if (metaRoute) {
            return metaRoute;
        }

        // Multi-hop through base pools
        return await this.findMultiHopRoute(tokenIn, tokenOut, amountIn);
    }

    async findDirectPool(tokenIn, tokenOut) {
        const curveRegistry = new ethers.Contract(CURVE_REGISTRY, REGISTRY_ABI, provider);
        return await curveRegistry.find_pool_for_coins(tokenIn, tokenOut);
    }

    async quoteCurveSwap(poolAddress, tokenIn, tokenOut, amountIn) {
        const pool = new ethers.Contract(poolAddress, CURVE_POOL_ABI, provider);
        const registry = new ethers.Contract(CURVE_REGISTRY, REGISTRY_ABI, provider);
        
        // Get coin indices
        const [i, j] = await registry.get_coin_indices(poolAddress, tokenIn, tokenOut);
        
        // Get quote
        return await pool.get_dy(i, j, amountIn);
    }
}
</code></pre>
<h3>Balancer V2 Integration</h3>
<p>Balancer supports multiple pool types requiring different strategies:</p>
<pre><code class="language-javascript">class BalancerOptimizer {
    async getOptimalBalancerRoute(tokenIn, tokenOut, amountIn) {
        const pools = await this.findBalancerPools(tokenIn, tokenOut);
        
        let bestRoute = null;
        let bestOutput = 0;

        for (const pool of pools) {
            try {
                const output = await this.quoteBalancerSwap(pool, tokenIn, tokenOut, amountIn);
                if (output &gt; bestOutput) {
                    bestOutput = output;
                    bestRoute = {
                        pool,
                        expectedOutput: output,
                        poolType: pool.poolType
                    };
                }
            } catch (error) {
                console.warn(`Failed to quote Balancer pool ${pool.id}:`, error);
            }
        }

        return bestRoute;
    }

    async findBalancerPools(tokenIn, tokenOut) {
        // Query Balancer subgraph for relevant pools
        const query = `
            query {
                pools(
                    where: {
                        tokensList_contains: [&quot;${tokenIn.toLowerCase()}&quot;, &quot;${tokenOut.toLowerCase()}&quot;]
                        swapEnabled: true
                    }
                    orderBy: totalLiquidity
                    orderDirection: desc
                ) {
                    id
                    poolType
                    swapFee
                    totalLiquidity
                    tokens {
                        address
                        balance
                        weight
                    }
                }
            }
        `;

        const response = await this.querySubgraph(BALANCER_SUBGRAPH_URL, query);
        return response.data.pools;
    }

    async quoteBalancerSwap(pool, tokenIn, tokenOut, amountIn) {
        const vault = new ethers.Contract(BALANCER_VAULT, VAULT_ABI, provider);
        
        // Prepare single swap
        const singleSwap = {
            poolId: pool.id,
            kind: 0, // GIVEN_IN
            assetIn: tokenIn,
            assetOut: tokenOut,
            amount: amountIn,
            userData: &#39;0x&#39;
        };

        const funds = {
            sender: ethers.ZeroAddress,
            fromInternalBalance: false,
            recipient: ethers.ZeroAddress,
            toInternalBalance: false
        };

        // Query swap (doesn&#39;t execute)
        return await vault.queryBatchSwap(0, [singleSwap], [tokenIn, tokenOut], funds);
    }
}
</code></pre>
<h2>Performance Metrics</h2>
<h3>Liquidity Depth Analysis</h3>
<pre><code class="language-javascript">class LiquidityAnalyzer {
    async analyzeLiquidityDepth(dexName, tokenPair, chainId) {
        const metrics = {
            totalLiquidity: 0,
            priceImpact: {},
            slippageAnalysis: {},
            volumeMetrics: {}
        };

        // Analyze different trade sizes
        const tradeSizes = [1000, 5000, 10000, 50000, 100000]; // USD equivalent
        
        for (const size of tradeSizes) {
            const quote = await this.getQuoteForSize(dexName, tokenPair, size, chainId);
            metrics.priceImpact[size] = quote.priceImpact;
            metrics.slippageAnalysis[size] = quote.slippage;
        }

        // Get 24h volume data
        metrics.volumeMetrics = await this.get24hVolumeData(dexName, tokenPair, chainId);

        return metrics;
    }

    async getQuoteForSize(dexName, tokenPair, usdSize, chainId) {
        // Convert USD size to token amount
        const tokenPrice = await this.getTokenPrice(tokenPair.tokenIn);
        const tokenAmount = usdSize / tokenPrice;

        // Get quote from specific DEX
        const quote = await this.getDEXQuote(dexName, tokenPair, tokenAmount, chainId);
        
        return {
            inputAmount: tokenAmount,
            outputAmount: quote.outputAmount,
            priceImpact: this.calculatePriceImpact(tokenAmount, quote.outputAmount, tokenPrice),
            slippage: quote.slippage,
            gasEstimate: quote.gasEstimate
        };
    }

    calculatePriceImpact(amountIn, amountOut, marketPrice) {
        const executionPrice = amountOut / amountIn;
        return Math.abs((marketPrice - executionPrice) / marketPrice);
    }
}
</code></pre>
<h2>Integration Status</h2>
<h3>Mainnet Status</h3>
<ul>
<li>‚úÖ <strong>Uniswap V2/V3</strong>: Full integration with all fee tiers</li>
<li>‚úÖ <strong>SushiSwap</strong>: Complete V2/V3 support</li>
<li>‚úÖ <strong>Curve</strong>: All pool types supported</li>
<li>‚úÖ <strong>Balancer V2</strong>: Weighted, stable, and boosted pools</li>
<li>‚úÖ <strong>1inch</strong>: Secondary aggregation</li>
<li>‚ö†Ô∏è <strong>0x Protocol</strong>: RFQ integration pending</li>
<li>‚ö†Ô∏è <strong>Kyber Network</strong>: Dynamic MMM support in progress</li>
</ul>
<h3>Layer 2 Status</h3>
<ul>
<li>‚úÖ <strong>Polygon</strong>: QuickSwap, SushiSwap, Curve</li>
<li>‚úÖ <strong>Arbitrum</strong>: Uniswap V3, Camelot, GMX, Ramses</li>
<li>‚úÖ <strong>Optimism</strong>: Uniswap V3, Velodrome, Beethoven X</li>
<li>‚úÖ <strong>Base</strong>: Uniswap V3, Aerodrome</li>
<li>‚ö†Ô∏è <strong>zkSync Era</strong>: Integration in development</li>
<li>‚ö†Ô∏è <strong>Polygon zkEVM</strong>: Integration planned</li>
</ul>
<h3>Sidechain Status</h3>
<ul>
<li>‚úÖ <strong>BSC</strong>: PancakeSwap V2/V3, Thena, Biswap</li>
<li>‚úÖ <strong>Avalanche</strong>: Trader Joe V2, Platypus, Pangolin</li>
<li>‚úÖ <strong>Fantom</strong>: SpookySwap, SpiritSwap, Beethoven X</li>
<li>‚ö†Ô∏è <strong>Cronos</strong>: Integration planned</li>
<li>‚ö†Ô∏è <strong>Celo</strong>: Integration planned</li>
</ul>
<h2>Adding New DEXes</h2>
<h3>Integration Requirements</h3>
<ol>
<li><strong>Smart Contract Audit</strong>: All DEX integrations must be audited</li>
<li><strong>Liquidity Threshold</strong>: Minimum $100k TVL required</li>
<li><strong>Reliability</strong>: 99%+ uptime over 30-day period</li>
<li><strong>API Stability</strong>: Consistent interface and minimal breaking changes</li>
<li><strong>Community Support</strong>: Active development and community</li>
</ol>
<h3>Integration Process</h3>
<ol>
<li><strong>Technical Assessment</strong>: Review DEX architecture and APIs</li>
<li><strong>Security Review</strong>: Audit smart contracts and integration code</li>
<li><strong>Testing Phase</strong>: Extensive testing on testnets</li>
<li><strong>Liquidity Analysis</strong>: Evaluate impact on routing efficiency</li>
<li><strong>Mainnet Deployment</strong>: Gradual rollout with monitoring</li>
<li><strong>Performance Monitoring</strong>: Continuous tracking of metrics</li>
</ol>
<h3>Contributing New DEX Integrations</h3>
<p>Developers can contribute new DEX integrations following our <a href="../guides/integration.md">Integration Guide</a>. All contributions must include:</p>
<ul>
<li>Smart contract integration code</li>
<li>Comprehensive test suite</li>
<li>Documentation updates</li>
<li>Security analysis report</li>
<li>Performance benchmarks</li>
</ul>
<h2>Resources</h2>
<ul>
<li><a href="overview.md">DEX Aggregation Overview</a></li>
<li><a href="routing-algorithm.md">Routing Algorithm</a></li>
<li><a href="quote-system.md">Quote System</a></li>
<li><a href="router-types.md">Router Types</a></li>
<li><a href="../examples/dex-aggregation.md">Integration Examples</a></li>
</ul>
<div class="page-break"></div><h1 id="relayer-network">Relayer Network</h1><p>The IU2U Protocol relies on a decentralized relayer network to facilitate secure cross-chain communication and token transfers between different blockchain networks.</p>
<h2>Overview</h2>
<p>The relayer network serves as the bridge infrastructure that monitors events on source chains, validates cross-chain transactions, and executes corresponding actions on destination chains. This decentralized approach ensures security, reliability, and censorship resistance.</p>
<h2>Architecture</h2>
<pre><code class="language-mermaid">flowchart TB
    subgraph &quot;Source Chain&quot;
        SC[Smart Contract]
        SE[Event Emitter]
    end
    
    subgraph &quot;Relayer Network&quot;
        R1[Relayer 1]
        R2[Relayer 2]
        R3[Relayer 3]
        RN[Relayer N]
        MS[Multi-Sig Validator]
    end
    
    subgraph &quot;Destination Chain&quot;
        DG[IU2U Gateway]
        DC[Destination Contract]
    end
    
    SC --&gt; SE
    SE --&gt; R1
    SE --&gt; R2
    SE --&gt; R3
    SE --&gt; RN
    R1 --&gt; MS
    R2 --&gt; MS
    R3 --&gt; MS
    RN --&gt; MS
    MS --&gt; DG
    DG --&gt; DC
    
</code></pre>
<h2>Relayer Roles</h2>
<h3>1. Event Monitoring</h3>
<p>Relayers continuously monitor supported blockchains for cross-chain events:</p>
<pre><code class="language-javascript">class EventMonitor {
    constructor(config) {
        this.provider = new ethers.JsonRpcProvider(config.rpc);
        this.gateway = new ethers.Contract(config.gatewayAddress, gatewayABI, this.provider);
        this.blockConfirmations = config.blockConfirmations;
    }

    async monitorEvents() {
        this.gateway.on(&quot;ContractCall&quot;, async (sender, destinationChain, contractAddress, payloadHash, payload, event) =&gt; {
            await this.processEvent({
                type: &quot;CONTRACT_CALL&quot;,
                sourceChain: this.chainName,
                txHash: event.transactionHash,
                logIndex: event.logIndex,
                sender,
                destinationChain,
                contractAddress,
                payloadHash,
                payload
            });
        });

        this.gateway.on(&quot;ContractCallWithToken&quot;, async (sender, destinationChain, contractAddress, payloadHash, payload, symbol, amount, event) =&gt; {
            await this.processEvent({
                type: &quot;CONTRACT_CALL_WITH_TOKEN&quot;,
                sourceChain: this.chainName,
                txHash: event.transactionHash,
                logIndex: event.logIndex,
                sender,
                destinationChain,
                contractAddress,
                payloadHash,
                payload,
                symbol,
                amount
            });
        });
    }
}
</code></pre>
<h3>2. Transaction Validation</h3>
<p>Each relayer independently validates cross-chain transactions:</p>
<pre><code class="language-javascript">class TransactionValidator {
    async validateTransaction(event) {
        // Check block confirmations
        const currentBlock = await this.provider.getBlockNumber();
        const eventBlock = event.blockNumber;
        
        if (currentBlock - eventBlock &lt; this.blockConfirmations) {
            return { valid: false, reason: &quot;Insufficient confirmations&quot; };
        }

        // Verify event authenticity
        const receipt = await this.provider.getTransactionReceipt(event.txHash);
        const eventLog = receipt.logs.find(log =&gt; 
            log.logIndex === event.logIndex &amp;&amp; 
            log.transactionHash === event.txHash
        );

        if (!eventLog) {
            return { valid: false, reason: &quot;Event not found&quot; };
        }

        // Validate payload hash
        const computedHash = ethers.keccak256(event.payload);
        if (computedHash !== event.payloadHash) {
            return { valid: false, reason: &quot;Payload hash mismatch&quot; };
        }

        // Check for replay attacks
        const commandId = this.generateCommandId(event.txHash, event.logIndex);
        if (await this.isCommandExecuted(commandId)) {
            return { valid: false, reason: &quot;Command already executed&quot; };
        }

        return { valid: true };
    }
}
</code></pre>
<h3>3. Command Signing</h3>
<p>Valid transactions are signed by relayers using their private keys:</p>
<pre><code class="language-javascript">class CommandSigner {
    constructor(privateKey) {
        this.wallet = new ethers.Wallet(privateKey);
    }

    async signCommand(event) {
        const commandId = this.generateCommandId(event.txHash, event.logIndex);
        
        const commandData = ethers.AbiCoder.defaultAbiCoder().encode([
            &#39;bytes32&#39;,  // commandId
            &#39;string&#39;,   // sourceChain
            &#39;string&#39;,   // sourceAddress
            &#39;bytes32&#39;,  // payloadHash
            &#39;bytes&#39;     // payload
        ], [
            commandId,
            event.sourceChain,
            event.sender,
            event.payloadHash,
            event.payload
        ]);

        const messageHash = ethers.keccak256(commandData);
        const signature = await this.wallet.signMessage(ethers.getBytes(messageHash));
        
        return {
            commandId,
            signature,
            signer: this.wallet.address
        };
    }
}
</code></pre>
<h3>4. Command Execution</h3>
<p>Once sufficient signatures are collected, commands are executed on destination chains:</p>
<pre><code class="language-javascript">class CommandExecutor {
    async executeCommand(command, signatures) {
        // Verify minimum signature threshold
        if (signatures.length &lt; this.minSignatures) {
            throw new Error(&quot;Insufficient signatures&quot;);
        }

        // Prepare execution data
        const executionData = ethers.AbiCoder.defaultAbiCoder().encode([
            &#39;bytes32&#39;,     // commandId
            &#39;string&#39;,      // sourceChain
            &#39;string&#39;,      // sourceAddress
            &#39;bytes&#39;,       // payload
            &#39;bytes32[]&#39;,   // signatures
            &#39;address[]&#39;    // signers
        ], [
            command.commandId,
            command.sourceChain,
            command.sourceAddress,
            command.payload,
            signatures.map(s =&gt; s.signature),
            signatures.map(s =&gt; s.signer)
        ]);

        // Execute on destination chain
        const gateway = new ethers.Contract(
            this.getGatewayAddress(command.destinationChain),
            gatewayABI,
            this.getSigner(command.destinationChain)
        );

        const tx = await gateway.execute(executionData);
        const receipt = await tx.wait();

        return receipt;
    }
}
</code></pre>
<h2>Security Model</h2>
<h3>Multi-Signature Validation</h3>
<p>The network requires multiple relayer signatures for each cross-chain operation:</p>
<pre><code class="language-solidity">contract RelayerManager {
    mapping(address =&gt; bool) public isRelayer;
    uint256 public minSignatures;
    uint256 public relayerCount;
    
    function validateSignatures(
        bytes32 commandId,
        bytes32[] memory signatures,
        address[] memory signers
    ) public view returns (bool) {
        require(signatures.length &gt;= minSignatures, &quot;Insufficient signatures&quot;);
        require(signatures.length == signers.length, &quot;Signature count mismatch&quot;);
        
        bytes32 messageHash = keccak256(abi.encode(commandId));
        uint256 validSignatures = 0;
        
        for (uint256 i = 0; i &lt; signatures.length; i++) {
            if (isRelayer[signers[i]] &amp;&amp; _verifySignature(messageHash, signatures[i], signers[i])) {
                validSignatures++;
            }
        }
        
        return validSignatures &gt;= minSignatures;
    }
}
</code></pre>
<h3>Stake-Based Security</h3>
<p>Relayers must stake IU2U tokens to participate in the network:</p>
<pre><code class="language-solidity">contract RelayerStaking {
    struct RelayerInfo {
        uint256 stake;
        uint256 rewards;
        uint256 penalties;
        bool isActive;
        uint256 joinedAt;
    }
    
    mapping(address =&gt; RelayerInfo) public relayers;
    uint256 public minimumStake = 10000 ether; // 10,000 IU2U
    uint256 public slashingAmount = 1000 ether; // 1,000 IU2U
    
    function stakeAsRelayer(uint256 amount) external {
        require(amount &gt;= minimumStake, &quot;Insufficient stake&quot;);
        
        IU2U.transferFrom(msg.sender, address(this), amount);
        
        relayers[msg.sender] = RelayerInfo({
            stake: amount,
            rewards: 0,
            penalties: 0,
            isActive: true,
            joinedAt: block.timestamp
        });
        
        emit RelayerStaked(msg.sender, amount);
    }
    
    function slashRelayer(address relayer, string memory reason) external onlyGovernance {
        require(relayers[relayer].isActive, &quot;Relayer not active&quot;);
        
        uint256 slashAmount = min(relayers[relayer].stake, slashingAmount);
        relayers[relayer].stake -= slashAmount;
        relayers[relayer].penalties += slashAmount;
        
        if (relayers[relayer].stake &lt; minimumStake) {
            relayers[relayer].isActive = false;
        }
        
        emit RelayerSlashed(relayer, slashAmount, reason);
    }
}
</code></pre>
<h3>Performance Monitoring</h3>
<p>The network monitors relayer performance and availability:</p>
<pre><code class="language-javascript">class RelayerMonitor {
    constructor() {
        this.performanceMetrics = new Map();
    }

    trackEventProcessing(relayerAddress, eventId, processingTime, success) {
        if (!this.performanceMetrics.has(relayerAddress)) {
            this.performanceMetrics.set(relayerAddress, {
                totalEvents: 0,
                successfulEvents: 0,
                averageProcessingTime: 0,
                uptime: 0
            });
        }

        const metrics = this.performanceMetrics.get(relayerAddress);
        metrics.totalEvents++;
        
        if (success) {
            metrics.successfulEvents++;
        }

        // Update average processing time
        metrics.averageProcessingTime = (
            (metrics.averageProcessingTime * (metrics.totalEvents - 1)) + processingTime
        ) / metrics.totalEvents;

        this.performanceMetrics.set(relayerAddress, metrics);
    }

    getRelayerScore(relayerAddress) {
        const metrics = this.performanceMetrics.get(relayerAddress);
        if (!metrics) return 0;

        const successRate = metrics.successfulEvents / metrics.totalEvents;
        const speedScore = Math.max(0, 1 - (metrics.averageProcessingTime / 300000)); // 5 min baseline
        
        return (successRate * 0.7) + (speedScore * 0.3);
    }
}
</code></pre>
<h2>Relayer Operations</h2>
<h3>Running a Relayer Node</h3>
<h4>Hardware Requirements</h4>
<table>
<thead>
<tr>
<th>Component</th>
<th>Minimum</th>
<th>Recommended</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>4 cores</td>
<td>8 cores</td>
</tr>
<tr>
<td>RAM</td>
<td>8 GB</td>
<td>16 GB</td>
</tr>
<tr>
<td>Storage</td>
<td>100 GB SSD</td>
<td>500 GB SSD</td>
</tr>
<tr>
<td>Network</td>
<td>100 Mbps</td>
<td>1 Gbps</td>
</tr>
<tr>
<td>Uptime</td>
<td>95%</td>
<td>99.9%</td>
</tr>
</tbody></table>
<h4>Software Setup</h4>
<pre><code class="language-bash"># Clone relayer software
git clone https://github.com/DINetworks/IU2U-Relayer.git
cd IU2U-Relayer

# Install dependencies
npm install

# Configure relayer
cp config.example.json config.json
# Edit config.json with your settings

# Generate relayer keypair
npm run generate-keys

# Start relayer
npm start
</code></pre>
<h4>Configuration Example</h4>
<pre><code class="language-json">{
  &quot;relayer&quot;: {
    &quot;address&quot;: &quot;0x742d35Cc6aB8C0532FdA5c5F8E71c1e4bF7dc789&quot;,
    &quot;privateKey&quot;: &quot;0x...&quot;,
    &quot;stake&quot;: &quot;50000000000000000000000&quot;
  },
  &quot;chains&quot;: {
    &quot;ethereum&quot;: {
      &quot;rpc&quot;: &quot;wss://mainnet.infura.io/ws/v3/YOUR_PROJECT_ID&quot;,
      &quot;chainId&quot;: 1,
      &quot;gatewayAddress&quot;: &quot;0x...&quot;,
      &quot;blockConfirmations&quot;: 12,
      &quot;gasPrice&quot;: &quot;20000000000&quot;
    },
    &quot;bsc&quot;: {
      &quot;rpc&quot;: &quot;wss://bsc-ws-node.nariox.org:443&quot;,
      &quot;chainId&quot;: 56,
      &quot;gatewayAddress&quot;: &quot;0x...&quot;,
      &quot;blockConfirmations&quot;: 3,
      &quot;gasPrice&quot;: &quot;5000000000&quot;
    }
  },
  &quot;monitoring&quot;: {
    &quot;enabled&quot;: true,
    &quot;metricsPort&quot;: 9090,
    &quot;healthCheckPort&quot;: 8080
  }
}
</code></pre>
<h3>Economic Incentives</h3>
<h4>Reward Distribution</h4>
<p>Relayers earn rewards for successful cross-chain operations:</p>
<pre><code class="language-solidity">contract RelayerRewards {
    uint256 public constant REWARD_PER_EXECUTION = 1 ether; // 1 IU2U
    uint256 public constant BONUS_MULTIPLIER = 150; // 1.5x for fast execution
    
    function distributeRewards(
        address[] memory executingRelayers,
        uint256 executionTime,
        uint256 averageExecutionTime
    ) external {
        uint256 baseReward = REWARD_PER_EXECUTION / executingRelayers.length;
        
        for (uint256 i = 0; i &lt; executingRelayers.length; i++) {
            uint256 reward = baseReward;
            
            // Bonus for fast execution
            if (executionTime &lt; averageExecutionTime) {
                reward = (reward * BONUS_MULTIPLIER) / 100;
            }
            
            relayers[executingRelayers[i]].rewards += reward;
            IU2U.mint(executingRelayers[i], reward);
            
            emit RewardDistributed(executingRelayers[i], reward);
        }
    }
}
</code></pre>
<h4>Fee Structure</h4>
<table>
<thead>
<tr>
<th>Operation Type</th>
<th>Base Fee</th>
<th>Relayer Share</th>
</tr>
</thead>
<tbody><tr>
<td>Token Transfer</td>
<td>0.1%</td>
<td>80%</td>
</tr>
<tr>
<td>Contract Call</td>
<td>0.05%</td>
<td>80%</td>
</tr>
<tr>
<td>Complex Execution</td>
<td>0.15%</td>
<td>80%</td>
</tr>
</tbody></table>
<h3>Governance</h3>
<h4>Relayer Selection</h4>
<p>New relayers are admitted through a governance process:</p>
<pre><code class="language-solidity">contract RelayerGovernance {
    struct RelayerProposal {
        address candidate;
        uint256 proposedStake;
        uint256 votesFor;
        uint256 votesAgainst;
        uint256 deadline;
        bool executed;
    }
    
    function proposeRelayer(address candidate, uint256 stake) external {
        require(IU2U.balanceOf(candidate) &gt;= stake, &quot;Insufficient balance&quot;);
        
        uint256 proposalId = nextProposalId++;
        proposals[proposalId] = RelayerProposal({
            candidate: candidate,
            proposedStake: stake,
            votesFor: 0,
            votesAgainst: 0,
            deadline: block.timestamp + 7 days,
            executed: false
        });
        
        emit RelayerProposed(proposalId, candidate, stake);
    }
    
    function voteOnProposal(uint256 proposalId, bool support) external {
        require(relayers[msg.sender].isActive, &quot;Only active relayers can vote&quot;);
        
        RelayerProposal storage proposal = proposals[proposalId];
        require(block.timestamp &lt;= proposal.deadline, &quot;Voting period ended&quot;);
        
        uint256 votingPower = relayers[msg.sender].stake;
        
        if (support) {
            proposal.votesFor += votingPower;
        } else {
            proposal.votesAgainst += votingPower;
        }
        
        emit VoteCast(proposalId, msg.sender, support, votingPower);
    }
}
</code></pre>
<h2>Network Health</h2>
<h3>Monitoring Dashboard</h3>
<p>Real-time network health metrics:</p>
<pre><code class="language-javascript">class NetworkHealthMonitor {
    async getNetworkHealth() {
        const metrics = {
            activeRelayers: await this.getActiveRelayerCount(),
            totalStake: await this.getTotalStakedAmount(),
            averageResponseTime: await this.getAverageResponseTime(),
            successRate: await this.getSuccessRate(),
            pendingTransactions: await this.getPendingTransactionCount()
        };

        return {
            ...metrics,
            healthScore: this.calculateHealthScore(metrics),
            status: this.getNetworkStatus(metrics)
        };
    }

    calculateHealthScore(metrics) {
        const relayerScore = Math.min(metrics.activeRelayers / 10, 1); // Target: 10+ relayers
        const stakeScore = Math.min(metrics.totalStake / 1000000, 1); // Target: 1M IU2U
        const responseScore = Math.max(0, 1 - (metrics.averageResponseTime / 300)); // Target: &lt;5 min
        const successScore = metrics.successRate;

        return (relayerScore * 0.3) + (stakeScore * 0.2) + (responseScore * 0.3) + (successScore * 0.2);
    }
}
</code></pre>
<h3>Alert System</h3>
<p>Automated alerts for network issues:</p>
<pre><code class="language-javascript">class AlertSystem {
    constructor() {
        this.thresholds = {
            minActiveRelayers: 3,
            maxResponseTime: 600, // 10 minutes
            minSuccessRate: 0.95
        };
    }

    async checkAlerts() {
        const health = await this.healthMonitor.getNetworkHealth();

        if (health.activeRelayers &lt; this.thresholds.minActiveRelayers) {
            this.sendAlert({
                level: &#39;CRITICAL&#39;,
                message: `Only ${health.activeRelayers} active relayers remaining`,
                action: &#39;RECRUIT_RELAYERS&#39;
            });
        }

        if (health.averageResponseTime &gt; this.thresholds.maxResponseTime) {
            this.sendAlert({
                level: &#39;WARNING&#39;,
                message: `Average response time: ${health.averageResponseTime}s`,
                action: &#39;OPTIMIZE_PERFORMANCE&#39;
            });
        }

        if (health.successRate &lt; this.thresholds.minSuccessRate) {
            this.sendAlert({
                level: &#39;CRITICAL&#39;,
                message: `Success rate dropped to ${health.successRate * 100}%`,
                action: &#39;INVESTIGATE_FAILURES&#39;
            });
        }
    }
}
</code></pre>
<h2>Future Enhancements</h2>
<h3>Planned Improvements</h3>
<ol>
<li><strong>Zero-Knowledge Proofs</strong>: Enhanced privacy for relayer operations</li>
<li><strong>Optimistic Execution</strong>: Faster finality with fraud proofs</li>
<li><strong>Cross-Chain Staking</strong>: Stake tokens on one chain, operate on another</li>
<li><strong>Dynamic Pricing</strong>: Adaptive fee structure based on network congestion</li>
</ol>
<h3>Research Areas</h3>
<ul>
<li><strong>Relayer Randomization</strong>: Random selection for enhanced security</li>
<li><strong>MEV Protection</strong>: Preventing maximal extractable value attacks</li>
<li><strong>Formal Verification</strong>: Mathematical proofs of relayer network security</li>
<li><strong>Interoperability Standards</strong>: Adoption of cross-chain communication protocols</li>
</ul>
<h2>Resources</h2>
<ul>
<li><a href="cross-chain-architecture.md">Cross-Chain Architecture</a></li>
<li><a href="security-model.md">Security Model</a></li>
<li><a href="../guides/deployment.md">Relayer Setup Guide</a></li>
<li><a href="../resources/troubleshooting.md">Network Monitoring</a></li>
</ul>
<div class="page-break"></div><h1 id="security-model">Security Model</h1><p>The IU2U Protocol implements a comprehensive security model designed to protect users, relayers, and the overall ecosystem from various attack vectors while maintaining decentralization and accessibility.</p>
<h2>Security Architecture Overview</h2>
<p>The IU2U security model is built on multiple layers of protection:</p>
<ol>
<li><strong>Cryptographic Security</strong>: EIP-712 signatures, multi-signature schemes, and secure key management</li>
<li><strong>Economic Security</strong>: Stake-based relayer network with slashing mechanisms</li>
<li><strong>Protocol Security</strong>: Rate limiting, gas griefing protection, and replay attack prevention</li>
<li><strong>Smart Contract Security</strong>: Formal verification, comprehensive testing, and audit practices</li>
<li><strong>Operational Security</strong>: Monitoring, incident response, and emergency procedures</li>
</ol>
<h2>Core Security Components</h2>
<h3>1. Signature Security</h3>
<h4>Multi-Signature Requirements</h4>
<p>Critical operations require multiple signatures from authorized parties:</p>
<pre><code class="language-solidity">contract IU2UMultiSig {
    uint256 public constant REQUIRED_SIGNATURES = 3;
    uint256 public constant MIN_SIGNERS = 5;
    
    mapping(address =&gt; bool) public isAuthorizedSigner;
    mapping(bytes32 =&gt; uint256) public signatureCount;
    mapping(bytes32 =&gt; mapping(address =&gt; bool)) public hasSignedOperation;
    
    modifier requireMultiSig(bytes32 operationHash) {
        require(signatureCount[operationHash] &gt;= REQUIRED_SIGNATURES, &quot;Insufficient signatures&quot;);
        _;
    }
    
    function submitSignature(
        bytes32 operationHash,
        bytes calldata signature
    ) external {
        require(isAuthorizedSigner[msg.sender], &quot;Unauthorized signer&quot;);
        require(!hasSignedOperation[operationHash][msg.sender], &quot;Already signed&quot;);
        
        // Verify signature
        address recovered = recoverSigner(operationHash, signature);
        require(recovered == msg.sender, &quot;Invalid signature&quot;);
        
        hasSignedOperation[operationHash][msg.sender] = true;
        signatureCount[operationHash]++;
        
        emit SignatureSubmitted(operationHash, msg.sender);
    }
}
</code></pre>
<h3>2. Economic Security Model</h3>
<h4>Relayer Staking Mechanism</h4>
<p>Relayers must stake tokens to participate in the network, creating economic incentives for honest behavior.</p>
<pre><code class="language-solidity">contract RelayerStaking {
    struct RelayerStake {
        uint256 stakedAmount;
        uint256 lockedUntil;
        uint256 reputation;
        bool isActive;
    }
    
    mapping(address =&gt; RelayerStake) public relayerStakes;
    
    uint256 public constant MIN_STAKE = 10000 * 10**18; // 10,000 IU2U tokens
    uint256 public constant LOCK_PERIOD = 30 days;
    uint256 public constant SLASH_COOLDOWN = 7 days;
    
    function stakeAsRelayer(uint256 amount) external {
        require(amount &gt;= MIN_STAKE, &quot;Insufficient stake amount&quot;);
        require(IU2U_TOKEN.transferFrom(msg.sender, address(this), amount), &quot;Transfer failed&quot;);
        
        RelayerStake storage stake = relayerStakes[msg.sender];
        stake.stakedAmount += amount;
        stake.lockedUntil = block.timestamp + LOCK_PERIOD;
        stake.isActive = true;
        
        emit RelayerStaked(msg.sender, amount);
    }
    
    function slashRelayer(
        address relayer,
        uint256 slashAmount,
        string memory reason
    ) external onlyGovernance {
        RelayerStake storage stake = relayerStakes[relayer];
        require(stake.stakedAmount &gt;= slashAmount, &quot;Insufficient stake to slash&quot;);
        
        stake.stakedAmount -= slashAmount;
        stake.reputation = stake.reputation &gt; 10 ? stake.reputation - 10 : 0;
        
        // Burn 50% of slashed tokens, reward treasury with 50%
        uint256 burnAmount = slashAmount / 2;
        uint256 treasuryAmount = slashAmount - burnAmount;
        
        IU2U_TOKEN.burn(burnAmount);
        IU2U_TOKEN.transfer(TREASURY_ADDRESS, treasuryAmount);
        
        emit RelayerSlashed(relayer, slashAmount, reason);
    }
}
</code></pre>
<h4>Slashing Conditions</h4>
<p>Relayers can be slashed for various misbehaviors:</p>
<ol>
<li><strong>Invalid Transaction Execution</strong>: Submitting transactions that don&#39;t match signed meta-transactions</li>
<li><strong>Double Spending</strong>: Attempting to execute the same meta-transaction multiple times</li>
<li><strong>Gas Griefing</strong>: Setting excessive gas limits or prices</li>
<li><strong>Availability Issues</strong>: Consistent downtime or failure to process transactions</li>
<li><strong>Malicious Behavior</strong>: Any attempt to compromise the protocol</li>
</ol>
<h3>3. Cross-Chain Security</h3>
<h4>Message Verification</h4>
<p>All cross-chain messages undergo rigorous verification:</p>
<pre><code class="language-solidity">contract CrossChainVerifier {
    struct CrossChainMessage {
        string sourceChain;
        address sourceAddress;
        bytes32 messageHash;
        uint256 timestamp;
        bytes payload;
    }
    
    mapping(bytes32 =&gt; bool) public processedMessages;
    mapping(string =&gt; bool) public validChains;
    mapping(string =&gt; uint256) public chainIds;
    
    function verifyAndExecuteMessage(
        CrossChainMessage calldata message,
        bytes[] calldata relayerSignatures
    ) external {
        bytes32 messageId = keccak256(abi.encode(message));
        require(!processedMessages[messageId], &quot;Message already processed&quot;);
        require(validChains[message.sourceChain], &quot;Invalid source chain&quot;);
        
        // Verify relayer signatures
        require(verifyRelayerSignatures(messageId, relayerSignatures), &quot;Invalid signatures&quot;);
        
        // Verify message age
        require(block.timestamp - message.timestamp &lt;= MAX_MESSAGE_AGE, &quot;Message too old&quot;);
        
        // Mark as processed before execution (reentrancy protection)
        processedMessages[messageId] = true;
        
        // Execute the message
        (bool success, bytes memory returnData) = address(this).call(message.payload);
        require(success, &quot;Message execution failed&quot;);
        
        emit CrossChainMessageExecuted(messageId, message.sourceChain, success);
    }
    
    function verifyRelayerSignatures(
        bytes32 messageHash,
        bytes[] calldata signatures
    ) internal view returns (bool) {
        require(signatures.length &gt;= MIN_RELAYER_SIGNATURES, &quot;Insufficient signatures&quot;);
        
        address[] memory signers = new address[](signatures.length);
        uint256 validSignatures = 0;
        
        for (uint256 i = 0; i &lt; signatures.length; i++) {
            address signer = recoverSigner(messageHash, signatures[i]);
            
            // Ensure no duplicate signers
            for (uint256 j = 0; j &lt; validSignatures; j++) {
                require(signers[j] != signer, &quot;Duplicate signer&quot;);
            }
            
            if (isAuthorizedRelayer(signer)) {
                signers[validSignatures] = signer;
                validSignatures++;
            }
        }
        
        return validSignatures &gt;= MIN_RELAYER_SIGNATURES;
    }
}
</code></pre>
<h4>Bridge Security</h4>
<p>Cross-chain token transfers use a secure lock-and-mint mechanism:</p>
<pre><code class="language-solidity">contract SecureBridge {
    mapping(string =&gt; mapping(string =&gt; uint256)) public chainLimits;
    mapping(string =&gt; mapping(address =&gt; uint256)) public dailyVolume;
    mapping(string =&gt; uint256) public lastVolumeReset;
    
    uint256 public constant DAILY_RESET_PERIOD = 1 days;
    uint256 public constant EMERGENCY_PAUSE_DURATION = 24 hours;
    
    bool public emergencyPaused;
    uint256 public pausedUntil;
    
    modifier notPaused() {
        require(!emergencyPaused || block.timestamp &gt; pausedUntil, &quot;Bridge paused&quot;);
        _;
    }
    
    modifier withinLimits(string memory chain, address token, uint256 amount) {
        uint256 dailyLimit = chainLimits[chain][tokenSymbol(token)];
        
        // Reset daily volume if needed
        if (block.timestamp - lastVolumeReset[chain] &gt;= DAILY_RESET_PERIOD) {
            dailyVolume[chain][token] = 0;
            lastVolumeReset[chain] = block.timestamp;
        }
        
        require(dailyVolume[chain][token] + amount &lt;= dailyLimit, &quot;Daily limit exceeded&quot;);
        dailyVolume[chain][token] += amount;
        _;
    }
    
    function bridgeTokens(
        string memory targetChain,
        address token,
        uint256 amount,
        address recipient
    ) external notPaused withinLimits(targetChain, token, amount) {
        require(amount &gt; 0, &quot;Invalid amount&quot;);
        require(recipient != address(0), &quot;Invalid recipient&quot;);
        
        // Lock tokens on source chain
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        
        // Emit bridge event for relayers
        emit TokensBridged(
            block.chainid,
            targetChain,
            token,
            amount,
            msg.sender,
            recipient,
            block.timestamp
        );
    }
    
    function emergencyPause() external onlyEmergencyCouncil {
        emergencyPaused = true;
        pausedUntil = block.timestamp + EMERGENCY_PAUSE_DURATION;
        emit EmergencyPause(block.timestamp);
    }
}
</code></pre>
<h3>4. Smart Contract Security</h3>
<h4>Access Control</h4>
<p>Comprehensive role-based access control system:</p>
<pre><code class="language-solidity">contract IU2UAccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256(&quot;ADMIN_ROLE&quot;);
    bytes32 public constant RELAYER_ROLE = keccak256(&quot;RELAYER_ROLE&quot;);
    bytes32 public constant EMERGENCY_ROLE = keccak256(&quot;EMERGENCY_ROLE&quot;);
    bytes32 public constant GOVERNANCE_ROLE = keccak256(&quot;GOVERNANCE_ROLE&quot;);
    
    mapping(bytes32 =&gt; mapping(address =&gt; bool)) public hasRole;
    mapping(bytes32 =&gt; bytes32) public roleAdmin;
    
    modifier onlyRole(bytes32 role) {
        require(hasRole[role][msg.sender], &quot;Access denied&quot;);
        _;
    }
    
    modifier onlyRoleOrAdmin(bytes32 role) {
        require(
            hasRole[role][msg.sender] || hasRole[ADMIN_ROLE][msg.sender],
            &quot;Access denied&quot;
        );
        _;
    }
    
    function grantRole(bytes32 role, address account) external {
        require(hasRole[roleAdmin[role]][msg.sender], &quot;Not role admin&quot;);
        hasRole[role][account] = true;
        emit RoleGranted(role, account, msg.sender);
    }
    
    function revokeRole(bytes32 role, address account) external {
        require(hasRole[roleAdmin[role]][msg.sender], &quot;Not role admin&quot;);
        hasRole[role][account] = false;
        emit RoleRevoked(role, account, msg.sender);
    }
}
</code></pre>
<h4>Reentrancy Protection</h4>
<p>Multiple layers of reentrancy protection:</p>
<pre><code class="language-solidity">contract ReentrancyGuard {
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;
    
    uint256 private status;
    
    constructor() {
        status = NOT_ENTERED;
    }
    
    modifier nonReentrant() {
        require(status != ENTERED, &quot;Reentrancy detected&quot;);
        status = ENTERED;
        _;
        status = NOT_ENTERED;
    }
    
    modifier nonReentrantView() {
        require(status != ENTERED, &quot;Reentrancy detected in view&quot;);
        _;
    }
}

// Enhanced reentrancy protection for specific functions
contract EnhancedReentrancyGuard {
    mapping(bytes4 =&gt; uint256) private functionStatus;
    
    modifier nonReentrantFunction() {
        bytes4 selector = msg.sig;
        require(functionStatus[selector] != ENTERED, &quot;Function reentrancy detected&quot;);
        functionStatus[selector] = ENTERED;
        _;
        functionStatus[selector] = NOT_ENTERED;
    }
}
</code></pre>
<h3>5. Gas Security</h3>
<h4>Gas Griefing Protection</h4>
<p>Protection against gas-related attacks:</p>
<pre><code class="language-solidity">contract GasSecurityManager {
    uint256 public constant MAX_GAS_LIMIT = 500000;
    uint256 public constant MIN_GAS_LIMIT = 21000;
    uint256 public constant GAS_BUFFER = 50000;
    
    mapping(address =&gt; uint256) public gasUsageHistory;
    mapping(address =&gt; uint256) public suspiciousGasCount;
    
    modifier gasSecure(uint256 gasLimit) {
        require(gasLimit &gt;= MIN_GAS_LIMIT &amp;&amp; gasLimit &lt;= MAX_GAS_LIMIT, &quot;Invalid gas limit&quot;);
        
        uint256 gasStart = gasleft();
        _;
        uint256 gasUsed = gasStart - gasleft();
        
        // Track unusual gas usage patterns
        if (gasUsed &gt; gasLimit + GAS_BUFFER) {
            suspiciousGasCount[msg.sender]++;
            if (suspiciousGasCount[msg.sender] &gt; 3) {
                emit SuspiciousGasUsage(msg.sender, gasUsed, gasLimit);
            }
        }
        
        gasUsageHistory[msg.sender] = gasUsed;
    }
    
    function estimateMetaTxGas(
        address target,
        bytes calldata data
    ) external view returns (uint256) {
        try this.simulateCall(target, data) {
            // Gas estimation succeeded
            return MIN_GAS_LIMIT;
        } catch {
            // Return conservative estimate for failed simulation
            return MAX_GAS_LIMIT;
        }
    }
    
    function simulateCall(address target, bytes calldata data) external view {
        require(msg.sender == address(this), &quot;Internal only&quot;);
        (bool success,) = target.staticcall(data);
        require(success, &quot;Simulation failed&quot;);
    }
}
</code></pre>
<h3>6. Oracle Security</h3>
<h4>Price Feed Security</h4>
<p>Secure price oracle implementation with multiple safeguards:</p>
<pre><code class="language-solidity">contract SecurePriceOracle {
    struct PriceData {
        uint256 price;
        uint256 timestamp;
        uint256 confidence;
        address source;
    }
    
    mapping(address =&gt; PriceData[]) public priceHistory;
    mapping(address =&gt; address[]) public priceSources;
    
    uint256 public constant MAX_PRICE_AGE = 300; // 5 minutes
    uint256 public constant MIN_SOURCES = 3;
    uint256 public constant MAX_DEVIATION = 500; // 5%
    
    function getPrice(address token) external view returns (uint256) {
        PriceData[] memory prices = getPricesFromSources(token);
        require(prices.length &gt;= MIN_SOURCES, &quot;Insufficient price sources&quot;);
        
        // Calculate median price
        uint256 medianPrice = calculateMedian(prices);
        
        // Verify price freshness
        for (uint256 i = 0; i &lt; prices.length; i++) {
            require(
                block.timestamp - prices[i].timestamp &lt;= MAX_PRICE_AGE,
                &quot;Stale price data&quot;
            );
        }
        
        // Check for price manipulation
        require(validatePriceDeviation(prices, medianPrice), &quot;Price manipulation detected&quot;);
        
        return medianPrice;
    }
    
    function validatePriceDeviation(
        PriceData[] memory prices,
        uint256 medianPrice
    ) internal pure returns (bool) {
        for (uint256 i = 0; i &lt; prices.length; i++) {
            uint256 deviation = prices[i].price &gt; medianPrice
                ? ((prices[i].price - medianPrice) * 10000) / medianPrice
                : ((medianPrice - prices[i].price) * 10000) / medianPrice;
                
            if (deviation &gt; MAX_DEVIATION) {
                return false;
            }
        }
        return true;
    }
    
    function calculateMedian(PriceData[] memory prices) internal pure returns (uint256) {
        // Sort prices
        for (uint256 i = 0; i &lt; prices.length - 1; i++) {
            for (uint256 j = 0; j &lt; prices.length - i - 1; j++) {
                if (prices[j].price &gt; prices[j + 1].price) {
                    PriceData memory temp = prices[j];
                    prices[j] = prices[j + 1];
                    prices[j + 1] = temp;
                }
            }
        }
        
        // Return median
        uint256 middle = prices.length / 2;
        if (prices.length % 2 == 0) {
            return (prices[middle - 1].price + prices[middle].price) / 2;
        } else {
            return prices[middle].price;
        }
    }
}
</code></pre>
<h2>Security Monitoring &amp; Response</h2>
<h3>1. Real-time Monitoring</h3>
<pre><code class="language-javascript">class SecurityMonitor {
    constructor(config) {
        this.contracts = config.contracts;
        this.alertThresholds = config.alertThresholds;
        this.alertHandlers = new Map();
        this.suspiciousActivities = new Map();
    }

    async startMonitoring() {
        // Monitor suspicious transaction patterns
        this.monitorTransactionPatterns();
        
        // Monitor gas usage anomalies
        this.monitorGasAnomalies();
        
        // Monitor cross-chain message delays
        this.monitorCrossChainDelays();
        
        // Monitor relayer behavior
        this.monitorRelayerBehavior();
    }

    monitorTransactionPatterns() {
        this.contracts.gateway.on(&quot;*&quot;, (event) =&gt; {
            this.analyzeTransactionPattern(event);
        });
    }

    analyzeTransactionPattern(event) {
        const { args, transactionHash, blockNumber } = event;
        
        // Check for rapid-fire transactions from same address
        if (this.isRapidFirePattern(args.user)) {
            this.triggerAlert(&#39;RAPID_FIRE_DETECTED&#39;, {
                user: args.user,
                transactionHash,
                blockNumber
            });
        }
        
        // Check for unusual gas patterns
        if (this.isUnusualGasPattern(event)) {
            this.triggerAlert(&#39;UNUSUAL_GAS_PATTERN&#39;, {
                transactionHash,
                gasUsed: event.gasUsed
            });
        }
        
        // Check for signature anomalies
        if (this.isSuspiciousSignature(args.signature)) {
            this.triggerAlert(&#39;SUSPICIOUS_SIGNATURE&#39;, {
                user: args.user,
                transactionHash
            });
        }
    }

    isRapidFirePattern(userAddress) {
        const recentTxs = this.getUserRecentTransactions(userAddress, 60000); // 1 minute
        return recentTxs.length &gt; this.alertThresholds.maxTxPerMinute;
    }

    triggerAlert(alertType, data) {
        const alert = {
            type: alertType,
            timestamp: Date.now(),
            data: data,
            severity: this.getAlertSeverity(alertType)
        };

        console.log(`Security Alert [${alert.severity}]: ${alertType}`, data);
        
        // Store alert
        this.storeAlert(alert);
        
        // Execute alert handlers
        const handlers = this.alertHandlers.get(alertType) || [];
        handlers.forEach(handler =&gt; handler(alert));
        
        // Auto-response for high severity alerts
        if (alert.severity === &#39;HIGH&#39;) {
            this.executeAutoResponse(alertType, data);
        }
    }

    executeAutoResponse(alertType, data) {
        switch (alertType) {
            case &#39;RAPID_FIRE_DETECTED&#39;:
                this.temporarilyBlockUser(data.user, 300000); // 5 minutes
                break;
            case &#39;SUSPICIOUS_SIGNATURE&#39;:
                this.flagUserForReview(data.user);
                break;
            case &#39;BRIDGE_ANOMALY&#39;:
                this.pauseBridgeIfNeeded(data.chain);
                break;
        }
    }
}
</code></pre>
<h3>2. Incident Response</h3>
<pre><code class="language-javascript">class IncidentResponse {
    constructor(contracts, emergencyContacts) {
        this.contracts = contracts;
        this.emergencyContacts = emergencyContacts;
        this.incidentLevels = {
            LOW: 1,
            MEDIUM: 2,
            HIGH: 3,
            CRITICAL: 4
        };
    }

    async handleSecurityIncident(incident) {
        const severity = this.assessSeverity(incident);
        
        // Log incident
        await this.logIncident(incident, severity);
        
        // Execute response based on severity
        switch (severity) {
            case this.incidentLevels.CRITICAL:
                await this.handleCriticalIncident(incident);
                break;
            case this.incidentLevels.HIGH:
                await this.handleHighSeverityIncident(incident);
                break;
            case this.incidentLevels.MEDIUM:
                await this.handleMediumSeverityIncident(incident);
                break;
            default:
                await this.handleLowSeverityIncident(incident);
        }
    }

    async handleCriticalIncident(incident) {
        // Emergency pause all operations
        await this.emergencyPauseAll();
        
        // Notify emergency response team
        await this.notifyEmergencyTeam(incident);
        
        // Initiate emergency governance vote if needed
        if (incident.requiresGovernance) {
            await this.initiateEmergencyVote(incident);
        }
        
        // Coordinate with external security firms
        await this.contactSecurityFirms(incident);
    }

    async emergencyPauseAll() {
        const pausePromises = [
            this.contracts.gateway.emergencyPause(),
            this.contracts.bridge.emergencyPause(),
            this.contracts.metaTxGateway.emergencyPause()
        ];
        
        await Promise.all(pausePromises);
        console.log(&#39;Emergency pause activated across all contracts&#39;);
    }

    async notifyEmergencyTeam(incident) {
        const message = this.formatEmergencyMessage(incident);
        
        // Send notifications through multiple channels
        const notifications = this.emergencyContacts.map(contact =&gt; 
            this.sendNotification(contact, message)
        );
        
        await Promise.all(notifications);
    }

    formatEmergencyMessage(incident) {
        return {
            subject: `CRITICAL SECURITY INCIDENT - ${incident.type}`,
            body: `
                Incident Type: ${incident.type}
                Severity: CRITICAL
                Time: ${new Date(incident.timestamp).toISOString()}
                Affected Components: ${incident.affectedComponents.join(&#39;, &#39;)}
                Description: ${incident.description}
                Immediate Actions Taken: ${incident.immediateActions.join(&#39;, &#39;)}
                
                Please respond immediately.
            `,
            priority: &#39;URGENT&#39;
        };
    }
}
</code></pre>
<h2>Security Best Practices</h2>
<h3>For Developers</h3>
<ol>
<li><strong>Input Validation</strong>: Always validate all inputs, especially cross-chain data</li>
<li><strong>Access Control</strong>: Use role-based access control for sensitive functions</li>
<li><strong>Gas Limits</strong>: Implement reasonable gas limits to prevent griefing</li>
<li><strong>Reentrancy Protection</strong>: Use nonReentrant modifiers on state-changing functions</li>
<li><strong>Emergency Procedures</strong>: Implement emergency pause mechanisms</li>
</ol>
<h3>For Relayers</h3>
<ol>
<li><strong>Key Management</strong>: Use hardware security modules for private key storage</li>
<li><strong>Infrastructure Security</strong>: Secure server environments and network access</li>
<li><strong>Monitoring</strong>: Implement comprehensive monitoring of relayer operations</li>
<li><strong>Backup Systems</strong>: Maintain redundant systems for high availability</li>
<li><strong>Regular Updates</strong>: Keep software and dependencies updated</li>
</ol>
<h3>For Users</h3>
<ol>
<li><strong>Signature Verification</strong>: Always verify transaction details before signing</li>
<li><strong>Trusted Interfaces</strong>: Use only official or verified interfaces</li>
<li><strong>Network Selection</strong>: Verify you&#39;re connected to the correct network</li>
<li><strong>Gas Settings</strong>: Review gas limits and prices before confirming</li>
<li><strong>Regular Monitoring</strong>: Monitor your accounts for unauthorized activity</li>
</ol>
<h2>Audit and Verification</h2>
<h3>Smart Contract Audits</h3>
<p>The IU2U Protocol undergoes regular security audits by leading firms:</p>
<ol>
<li><strong>Code Review</strong>: Line-by-line review of all smart contract code</li>
<li><strong>Automated Testing</strong>: Comprehensive test suites with high coverage</li>
<li><strong>Formal Verification</strong>: Mathematical proofs of critical properties</li>
<li><strong>Economic Analysis</strong>: Game theory analysis of incentive mechanisms</li>
<li><strong>Penetration Testing</strong>: Active attempts to find vulnerabilities</li>
</ol>
<h3>Continuous Security</h3>
<ol>
<li><strong>Bug Bounty Program</strong>: Rewards for finding and reporting vulnerabilities</li>
<li><strong>Regular Audits</strong>: Quarterly security reviews of all components</li>
<li><strong>Community Review</strong>: Open-source code for community inspection</li>
<li><strong>Security Updates</strong>: Rapid deployment of security patches</li>
<li><strong>Incident Analysis</strong>: Post-incident reviews to improve security</li>
</ol>
<h2>Emergency Procedures</h2>
<h3>Emergency Pause</h3>
<p>In case of critical security threats:</p>
<ol>
<li><strong>Immediate Pause</strong>: Emergency council can pause operations instantly</li>
<li><strong>Stakeholder Notification</strong>: All stakeholders notified within 1 hour</li>
<li><strong>Investigation</strong>: Security team begins immediate investigation</li>
<li><strong>Public Communication</strong>: Transparent communication with community</li>
<li><strong>Resolution</strong>: Systematic resolution and gradual service restoration</li>
</ol>
<h3>Recovery Procedures</h3>
<ol>
<li><strong>Impact Assessment</strong>: Determine scope and impact of security incident</li>
<li><strong>Vulnerability Patching</strong>: Fix identified vulnerabilities</li>
<li><strong>Testing</strong>: Comprehensive testing of fixes</li>
<li><strong>Gradual Resumption</strong>: Phased restart of services</li>
<li><strong>Post-Incident Review</strong>: Analysis and improvement of security measures</li>
</ol>
<h2>Conclusion</h2>
<p>The IU2U Protocol&#39;s security model is designed to provide robust protection while maintaining decentralization and usability. Through multiple layers of cryptographic, economic, and operational security measures, the protocol aims to create a secure environment for cross-chain operations.</p>
<p>Security is an ongoing process, and the protocol continuously evolves its security measures based on new threats, community feedback, and technological advances. All stakeholders play a crucial role in maintaining the security of the ecosystem.</p>
<h2>Resources</h2>
<ul>
<li><a href="protocol-overview.md">Protocol Overview</a></li>
<li><a href="relayer-network.md">Relayer Network</a></li>
<li><a href="cross-chain-architecture.md">Cross-Chain Architecture</a></li>
<li><a href="../api-reference/">API Security Guidelines</a></li>
<li><a href="../resources/emergency-procedures.md">Emergency Procedures</a></li>
</ul>
<div class="page-break"></div><h1 id="api-reference">API Reference</h1><p>The IU2U Gateway is the core contract that enables cross-chain communication and token transfers in the IU2U Protocol.</p>
<h2>Contract Interface</h2>
<pre><code class="language-solidity">interface IIU2UGateway {
    // Cross-chain messaging
    function callContract(
        string memory destinationChain,
        string memory contractAddress,
        bytes memory payload
    ) external;
    
    function callContractWithToken(
        string memory destinationChain,
        string memory contractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external;
    
    // Token operations
    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external;
    
    // Command execution
    function execute(bytes memory data) external;
    
    // Relayer management
    function isValidRelayer(address relayer) external view returns (bool);
    
    // Chain management
    function isValidChain(string memory chainName) external view returns (bool);
    
    // Status queries
    function isCommandExecuted(bytes32 commandId) external view returns (bool);
}
</code></pre>
<h2>Core Functions</h2>
<h3>callContract</h3>
<p>Initiates a cross-chain contract call without token transfer.</p>
<pre><code class="language-solidity">function callContract(
    string memory destinationChain,
    string memory contractAddress,
    bytes memory payload
) external
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>destinationChain</code>: Name of the target blockchain (e.g., &quot;ethereum&quot;, &quot;bsc&quot;)</li>
<li><code>contractAddress</code>: Address of the target contract on destination chain</li>
<li><code>payload</code>: Encoded function call data to execute</li>
</ul>
<p><strong>Events Emitted:</strong></p>
<pre><code class="language-solidity">event ContractCall(
    address indexed sender,
    string destinationChain,
    string destinationContractAddress,
    bytes32 indexed payloadHash,
    bytes payload
);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-solidity">bytes memory payload = abi.encodeWithSignature(
    &quot;updateValue(uint256)&quot;,
    42
);

gateway.callContract(
    &quot;ethereum&quot;,
    &quot;0x742d35Cc6aB8C0532FdA5c5F8E71c1e4b&quot;F,
    payload
);
</code></pre>
<h3>callContractWithToken</h3>
<p>Initiates a cross-chain contract call with token transfer.</p>
<pre><code class="language-solidity">function callContractWithToken(
    string memory destinationChain,
    string memory contractAddress,
    bytes memory payload,
    string memory symbol,
    uint256 amount
) external
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>destinationChain</code>: Name of the target blockchain</li>
<li><code>contractAddress</code>: Address of the target contract</li>
<li><code>payload</code>: Encoded function call data</li>
<li><code>symbol</code>: Token symbol to transfer (e.g., &quot;IU2U&quot;)</li>
<li><code>amount</code>: Amount of tokens to transfer</li>
</ul>
<p><strong>Events Emitted:</strong></p>
<pre><code class="language-solidity">event ContractCallWithToken(
    address indexed sender,
    string destinationChain,
    string destinationContractAddress,
    bytes32 indexed payloadHash,
    bytes payload,
    string symbol,
    uint256 amount
);
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-solidity">bytes memory stakePayload = abi.encodeWithSignature(
    &quot;stake(address,uint256)&quot;,
    msg.sender,
    ethers.parseEther(&quot;100&quot;)
);

gateway.callContractWithToken(
    &quot;polygon&quot;,
    stakingContractAddress,
    stakePayload,
    &quot;IU2U&quot;,
    ethers.parseEther(&quot;100&quot;)
);
</code></pre>
<h3>sendToken</h3>
<p>Transfers tokens to an address on another chain.</p>
<pre><code class="language-solidity">function sendToken(
    string memory destinationChain,
    string memory destinationAddress,
    string memory symbol,
    uint256 amount
) external
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>destinationChain</code>: Target blockchain name</li>
<li><code>destinationAddress</code>: Recipient address on destination chain</li>
<li><code>symbol</code>: Token symbol to transfer</li>
<li><code>amount</code>: Amount to transfer</li>
</ul>
<p><strong>Events Emitted:</strong></p>
<pre><code class="language-solidity">event TokenSent(
    address indexed sender,
    string destinationChain,
    string destinationAddress,
    string symbol,
    uint256 amount
);
</code></pre>
<h3>execute</h3>
<p>Executes approved cross-chain commands (relayer-only function).</p>
<pre><code class="language-solidity">function execute(bytes memory data) external onlyRelayer
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code>: Encoded command data including signatures and payload</li>
</ul>
<p><strong>Access Control:</strong> Only authorized relayers can call this function.</p>
<h2>View Functions</h2>
<h3>isValidRelayer</h3>
<p>Checks if an address is an authorized relayer.</p>
<pre><code class="language-solidity">function isValidRelayer(address relayer) external view returns (bool)
</code></pre>
<p><strong>Returns:</strong> <code>true</code> if the address is an authorized relayer</p>
<h3>isValidChain</h3>
<p>Checks if a chain name is supported.</p>
<pre><code class="language-solidity">function isValidChain(string memory chainName) external view returns (bool)
</code></pre>
<p><strong>Returns:</strong> <code>true</code> if the chain is supported</p>
<h3>isCommandExecuted</h3>
<p>Checks if a command has already been executed.</p>
<pre><code class="language-solidity">function isCommandExecuted(bytes32 commandId) external view returns (bool)
</code></pre>
<p><strong>Returns:</strong> <code>true</code> if the command has been executed</p>
<h2>Events</h2>
<h3>ContractCall</h3>
<p>Emitted when a cross-chain contract call is initiated.</p>
<pre><code class="language-solidity">event ContractCall(
    address indexed sender,
    string destinationChain,
    string destinationContractAddress,
    bytes32 indexed payloadHash,
    bytes payload
);
</code></pre>
<h3>ContractCallWithToken</h3>
<p>Emitted when a cross-chain contract call with token transfer is initiated.</p>
<pre><code class="language-solidity">event ContractCallWithToken(
    address indexed sender,
    string destinationChain,
    string destinationContractAddress,
    bytes32 indexed payloadHash,
    bytes payload,
    string symbol,
    uint256 amount
);
</code></pre>
<h3>TokenSent</h3>
<p>Emitted when tokens are sent cross-chain.</p>
<pre><code class="language-solidity">event TokenSent(
    address indexed sender,
    string destinationChain,
    string destinationAddress,
    string symbol,
    uint256 amount
);
</code></pre>
<h3>Executed</h3>
<p>Emitted when a cross-chain command is executed.</p>
<pre><code class="language-solidity">event Executed(
    bytes32 indexed commandId,
    string sourceChain,
    string sourceAddress,
    bool success,
    bytes returnData
);
</code></pre>
<h2>Error Codes</h2>
<pre><code class="language-solidity">error InvalidChain(string chainName);
error InvalidRelayer(address relayer);
error CommandAlreadyExecuted(bytes32 commandId);
error InsufficientBalance(uint256 requested, uint256 available);
error InvalidSignature();
error PayloadExecutionFailed(string reason);
</code></pre>
<h2>Gas Costs</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Estimated Gas</th>
<th>Factors</th>
</tr>
</thead>
<tbody><tr>
<td><code>callContract</code></td>
<td>80,000 - 150,000</td>
<td>Payload size, chain congestion</td>
</tr>
<tr>
<td><code>callContractWithToken</code></td>
<td>120,000 - 200,000</td>
<td>Token transfer, payload complexity</td>
</tr>
<tr>
<td><code>sendToken</code></td>
<td>60,000 - 100,000</td>
<td>Token type, destination chain</td>
</tr>
<tr>
<td><code>execute</code></td>
<td>100,000 - 300,000</td>
<td>Payload execution complexity</td>
</tr>
</tbody></table>
<h2>Integration Examples</h2>
<h3>Basic Integration</h3>
<pre><code class="language-solidity">contract MyDApp {
    IIU2UGateway public gateway;
    
    constructor(address _gateway) {
        gateway = IIU2UGateway(_gateway);
    }
    
    function crossChainUpdate(
        string memory targetChain,
        address targetContract,
        uint256 newValue
    ) external {
        bytes memory payload = abi.encodeWithSignature(
            &quot;updateValue(uint256)&quot;,
            newValue
        );
        
        gateway.callContract(
            targetChain,
            Strings.toHexString(uint160(targetContract), 20),
            payload
        );
    }
}
</code></pre>
<h3>Token Transfer Integration</h3>
<pre><code class="language-solidity">contract TokenBridge {
    IIU2UGateway public gateway;
    IERC20 public token;
    
    function bridgeTokens(
        string memory destinationChain,
        address recipient,
        uint256 amount
    ) external {
        // Transfer tokens from user
        token.transferFrom(msg.sender, address(this), amount);
        
        // Approve gateway
        token.approve(address(gateway), amount);
        
        // Send tokens cross-chain
        gateway.sendToken(
            destinationChain,
            Strings.toHexString(uint160(recipient), 20),
            &quot;IU2U&quot;,
            amount
        );
    }
}
</code></pre>
<h3>DeFi Integration</h3>
<pre><code class="language-solidity">contract CrossChainYield {
    IIU2UGateway public gateway;
    
    function depositToChain(
        string memory targetChain,
        address yieldContract,
        uint256 amount
    ) external {
        bytes memory depositPayload = abi.encodeWithSignature(
            &quot;deposit(address,uint256)&quot;,
            msg.sender,
            amount
        );
        
        gateway.callContractWithToken(
            targetChain,
            Strings.toHexString(uint160(yieldContract), 20),
            depositPayload,
            &quot;IU2U&quot;,
            amount
        );
    }
}
</code></pre>
<h2>Security Considerations</h2>
<h3>Input Validation</h3>
<p>Always validate inputs before calling gateway functions:</p>
<pre><code class="language-solidity">modifier validChain(string memory chainName) {
    require(gateway.isValidChain(chainName), &quot;Invalid chain&quot;);
    _;
}

modifier validAmount(uint256 amount) {
    require(amount &gt; 0, &quot;Amount must be positive&quot;);
    _;
}

function safeCallContract(
    string memory destinationChain,
    address contractAddress,
    bytes memory payload
) external validChain(destinationChain) {
    require(contractAddress != address(0), &quot;Invalid contract address&quot;);
    require(payload.length &gt; 0, &quot;Empty payload&quot;);
    
    gateway.callContract(
        destinationChain,
        Strings.toHexString(uint160(contractAddress), 20),
        payload
    );
}
</code></pre>
<h3>Access Control</h3>
<p>Implement proper access control for sensitive functions:</p>
<pre><code class="language-solidity">contract SecureGatewayUser {
    mapping(address =&gt; bool) public authorizedUsers;
    
    modifier onlyAuthorized() {
        require(authorizedUsers[msg.sender], &quot;Unauthorized&quot;);
        _;
    }
    
    function restrictedCrossChainCall(
        string memory destinationChain,
        address contractAddress,
        bytes memory payload
    ) external onlyAuthorized {
        gateway.callContract(destinationChain, contractAddress, payload);
    }
}
</code></pre>
<h3>Reentrancy Protection</h3>
<p>Use reentrancy guards for functions that transfer tokens:</p>
<pre><code class="language-solidity">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;

contract SecureTokenBridge is ReentrancyGuard {
    function bridgeTokens(
        string memory destinationChain,
        address recipient,
        uint256 amount
    ) external nonReentrant {
        // Bridge logic here
    }
}
</code></pre>
<h2>Upgradeability</h2>
<p>The IU2U Gateway uses a proxy pattern for upgradeability:</p>
<pre><code class="language-solidity">// Proxy interface
interface IGatewayProxy {
    function implementation() external view returns (address);
    function admin() external view returns (address);
    function upgrade(address newImplementation) external;
}
</code></pre>
<h2>Monitoring and Analytics</h2>
<h3>Event Monitoring</h3>
<p>Monitor gateway events for cross-chain activity:</p>
<pre><code class="language-javascript">const gateway = new ethers.Contract(gatewayAddress, gatewayABI, provider);

// Listen for contract calls
gateway.on(&quot;ContractCall&quot;, (sender, destinationChain, contractAddress, payloadHash, payload) =&gt; {
    console.log(`Cross-chain call from ${sender} to ${destinationChain}`);
});

// Listen for token transfers
gateway.on(&quot;TokenSent&quot;, (sender, destinationChain, destinationAddress, symbol, amount) =&gt; {
    console.log(`${ethers.formatEther(amount)} ${symbol} sent to ${destinationChain}`);
});
</code></pre>
<h3>Transaction Tracking</h3>
<p>Track cross-chain transactions:</p>
<pre><code class="language-javascript">async function trackCrossChainTx(txHash) {
    const receipt = await provider.getTransactionReceipt(txHash);
    
    const contractCallEvents = receipt.logs.filter(log =&gt; 
        log.topics[0] === ethers.id(&quot;ContractCall(address,string,string,bytes32,bytes)&quot;)
    );
    
    for (const event of contractCallEvents) {
        const decoded = gateway.interface.parseLog(event);
        console.log(`Command ID: ${ethers.keccak256(
            ethers.AbiCoder.defaultAbiCoder().encode(
                [&quot;bytes32&quot;, &quot;uint256&quot;],
                [decoded.args.payloadHash, event.logIndex]
            )
        )}`);
    }
}
</code></pre>
<h2>Best Practices</h2>
<h3>1. Always Check Chain Support</h3>
<pre><code class="language-solidity">require(gateway.isValidChain(destinationChain), &quot;Unsupported chain&quot;);
</code></pre>
<h3>2. Validate Contract Addresses</h3>
<pre><code class="language-solidity">require(contractAddress != address(0), &quot;Invalid address&quot;);
</code></pre>
<h3>3. Handle Token Approvals</h3>
<pre><code class="language-solidity">IERC20(token).approve(address(gateway), amount);
</code></pre>
<h3>4. Implement Proper Error Handling</h3>
<pre><code class="language-solidity">try gateway.callContract(chain, contract, payload) {
    emit CrossChainCallSucceeded(chain, contract);
} catch Error(string memory reason) {
    emit CrossChainCallFailed(chain, contract, reason);
}
</code></pre>
<h3>5. Use Events for Tracking</h3>
<pre><code class="language-solidity">event CrossChainOperationInitiated(
    address indexed user,
    string indexed destinationChain,
    bytes32 indexed operationId
);
</code></pre>
<h2>Resources</h2>
<ul>
<li><a href="../core-concepts/cross-chain-architecture.md">Cross-Chain Architecture</a></li>
<li><a href="../cross-chain/message-passing.md">Message Passing Guide</a></li>
<li><a href="../examples/basic-swap.md">Integration Examples</a></li>
<li><a href="../guides/security.md">Security Best Practices</a></li>
</ul>
<div class="page-break"></div><h1 id="quick-start-guide">Quick Start Guide</h1><p>Get up and running with IU2U Protocol in just a few minutes! This guide combines <strong>Gasless Meta Transactions</strong> and <strong>IU2U Cross-Chain Protocol</strong> for seamless blockchain interactions.</p>
<h2>Overview</h2>
<p>IU2U Protocol is a unified system that enables:</p>
<ul>
<li><strong>üî• Gasless Meta Transactions</strong>: Execute any contract interaction without holding native gas tokens</li>
<li><strong>üåâ IU2U Cross-Chain Protocol</strong>: Seamless token transfers and DEX aggregation across 7+ blockchains</li>
</ul>
<p>In this quick start, you&#39;ll learn how to:</p>
<ol>
<li>Set up gas credits for gasless transactions</li>
<li>Execute gasless contract calls</li>
<li>Perform cross-chain IU2U transfers</li>
<li>Use DEX aggregation features</li>
<li>Integrate both systems in your dApp</li>
</ol>
<h2>1. Basic Setup</h2>
<h3>Frontend Integration</h3>
<p>Install and initialize the IU2U SDK with both gasless and cross-chain capabilities:</p>
<pre><code class="language-javascript">import {
  IU2UProvider,
  CrossChainAggregator,
  GasCreditVault,
  MetaTxGateway
} from &#39;@iu2u/sdk&#39;;
import { ethers } from &#39;ethers&#39;;

// Initialize Web3 provider
const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();

// Initialize IU2U Protocol (both systems)
const iu2u = new IU2UProvider({
  provider: provider,
  signer: signer,
  network: &#39;testnet&#39; // Use testnet for development
});

// Initialize components
const aggregator = new CrossChainAggregator({ provider, signer });
const gasVault = new GasCreditVault({ provider, signer });
const metaTxGateway = new MetaTxGateway({ provider, signer });
</code></pre>
<h3>Smart Contract Integration</h3>
<p>For direct smart contract integration with both systems:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import &quot;./interfaces/IIU2UGateway.sol&quot;;
import &quot;./IU2UExecutable.sol&quot;;
import &quot;./interfaces/IGasCreditVault.sol&quot;;

contract MyDApp is IU2UExecutable {
    IGasCreditVault public gasVault;
    IIU2UGateway public iu2uGateway;

    constructor(
        address gateway_,
        address gasVault_,
        address iu2uGateway_
    ) IU2UExecutable(gateway_) {
        gasVault = IGasCreditVault(gasVault_);
        iu2uGateway = IIU2UGateway(iu2uGateway_);
    }

    // Gasless function call
    function gaslessTransfer(address token, address to, uint256 amount) external {
        // This function can be called gaslessly via MetaTxGateway
        IERC20(token).transfer(to, amount);
    }

    // Cross-chain IU2U transfer
    function crossChainTransfer(
        string memory destinationChain,
        address destinationAddress,
        uint256 amount
    ) external {
        iu2uGateway.sendToken(destinationChain, _addressToString(destinationAddress), &quot;IU2U&quot;, amount);
    }
}
</code></pre>
<h2>2. Gas Credits Setup</h2>
<h3>Deposit Tokens for Gas Credits</h3>
<p>First, set up gas credits to enable gasless transactions:</p>
<pre><code class="language-javascript">async function setupGasCredits() {
  try {
    // Check supported tokens
    const supportedTokens = await gasVault.getWhitelistedTokens();
    console.log(&#39;Supported tokens:&#39;, supportedTokens);

    // Deposit USDC to get gas credits
    const usdcAddress = &#39;0x036CbD53842c5426634e7929541eC2318f3dCF7e&#39;; // USDC on testnet
    const depositAmount = ethers.utils.parseUnits(&#39;10&#39;, 6); // 10 USDC

    // Approve vault to spend tokens
    const usdc = new ethers.Contract(usdcAddress, ERC20_ABI, signer);
    await usdc.approve(gasVault.address, depositAmount);

    // Deposit and get credits
    const tx = await gasVault.deposit(usdcAddress, depositAmount);
    await tx.wait();

    // Check credit balance
    const credits = await gasVault.credits(await signer.getAddress());
    console.log(`Gas credits: $${ethers.utils.formatEther(credits)}`);

  } catch (error) {
    console.error(&#39;Gas credit setup failed:&#39;, error);
  }
}
</code></pre>
<h3>Check Gas Credit Balance</h3>
<pre><code class="language-javascript">async function checkCredits() {
  const userAddress = await signer.getAddress();
  const creditBalance = await gasVault.credits(userAddress);
  const creditValue = ethers.utils.formatEther(creditBalance);

  console.log(`Available gas credits: $${creditValue}`);

  // Estimate if you have enough for a transaction
  const estimatedCost = ethers.utils.parseEther(&#39;0.50&#39;); // $0.50
  const hasEnoughCredits = creditBalance.gte(estimatedCost);

  return { creditBalance, hasEnoughCredits };
}
</code></pre>
<h2>3. Gasless Transactions</h2>
<h3>Execute Gasless Contract Calls</h3>
<p>Execute any contract function without holding native gas tokens:</p>
<pre><code class="language-javascript">async function gaslessTransfer() {
  try {
    // Check gas credits first
    const { hasEnoughCredits } = await checkCredits();
    if (!hasEnoughCredits) {
      throw new Error(&#39;Insufficient gas credits. Please deposit more tokens.&#39;);
    }

    // Target contract and function
    const targetContract = &#39;0x1234567890123456789012345678901234567890&#39;; // Your contract
    const recipient = &#39;0x742d35Cc6634C0532925a3b8D4048b05fb2fE98c&#39;;
    const amount = ethers.utils.parseEther(&#39;1&#39;);

    // Encode function call
    const iface = new ethers.utils.Interface([&#39;function transfer(address,uint256)&#39;]);
    const data = iface.encodeFunctionData(&#39;transfer&#39;, [recipient, amount]);

    // Create meta-transaction
    const metaTx = {
      to: targetContract,
      value: 0, // No native token transfer
      data: data
    };

    // Get current nonce
    const userAddress = await signer.getAddress();
    const nonce = await metaTxGateway.getNonce(userAddress);

    // Set deadline (5 minutes from now)
    const deadline = Math.floor(Date.now() / 1000) + 300;

    // Get digest for signing
    const digest = await metaTxGateway.getSigningDigest(
      userAddress,
      [metaTx], // Single transaction
      nonce,
      deadline
    );

    // Sign the transaction
    const signature = await signer.signMessage(ethers.utils.arrayify(digest));

    // Execute via relayer
    const tx = await metaTxGateway.executeMetaTransactions(
      userAddress,
      [metaTx],
      signature,
      nonce,
      deadline
    );

    console.log(&#39;Gasless transaction executed:&#39;, tx.hash);

  } catch (error) {
    console.error(&#39;Gasless transaction failed:&#39;, error);
  }
}
</code></pre>
<h3>Batch Gasless Transactions</h3>
<p>Execute multiple operations in a single gasless transaction:</p>
<pre><code class="language-javascript">async function batchGaslessOperations() {
  try {
    const userAddress = await signer.getAddress();
    const nonce = await metaTxGateway.getNonce(userAddress);
    const deadline = Math.floor(Date.now() / 1000) + 300;

    // Multiple operations in one batch
    const metaTxs = [
      {
        to: tokenContract,
        value: 0,
        data: encodeTransfer(recipient1, ethers.utils.parseEther(&#39;1&#39;))
      },
      {
        to: stakingContract,
        value: 0,
        data: encodeStake(ethers.utils.parseEther(&#39;0.5&#39;))
      },
      {
        to: votingContract,
        value: 0,
        data: encodeVote(proposalId, true)
      }
    ];

    // Sign and execute batch
    const digest = await metaTxGateway.getSigningDigest(userAddress, metaTxs, nonce, deadline);
    const signature = await signer.signMessage(ethers.utils.arrayify(digest));

    const tx = await metaTxGateway.executeMetaTransactions(
      userAddress, metaTxs, signature, nonce, deadline
    );

    console.log(&#39;Batch gasless transactions executed:&#39;, tx.hash);

  } catch (error) {
    console.error(&#39;Batch transaction failed:&#39;, error);
  }
}
</code></pre>
<h2>4. IU2U Bridge Operations</h2>
<h3>Cross-Chain IU2U Transfers</h3>
<p>Send IU2U tokens across different blockchains:</p>
<pre><code class="language-javascript">async function sendIU2UCrossChain() {
  try {
    // Get IU2U token address on current chain
    const iu2uToken = await iu2u.getIU2UTokenAddress();

    // Approve gateway to spend IU2U
    const iu2u = new ethers.Contract(iu2uToken, ERC20_ABI, signer);
    const amount = ethers.utils.parseEther(&#39;10&#39;);
    await iu2u.approve(iu2uGateway.address, amount);

    // Send IU2U to BSC
    const tx = await iu2uGateway.sendToken(
      &#39;bsc&#39;, // destination chain
      &#39;0x742d35Cc6634C0532925a3b8D4048b05fb2fE98c&#39;, // recipient address
      &#39;IU2U&#39;,
      amount
    );

    console.log(&#39;IU2U cross-chain transfer initiated:&#39;, tx.hash);

    // Monitor transfer status
    const status = await iu2u.waitForTransferCompletion(tx.hash);
    console.log(&#39;Transfer completed:&#39;, status);

  } catch (error) {
    console.error(&#39;IU2U transfer failed:&#39;, error);
  }
}
</code></pre>
<h3>Cross-Chain Contract Calls</h3>
<p>Execute contracts on other chains with IU2U transfers:</p>
<pre><code class="language-javascript">async function crossChainContractCall() {
  try {
    // Target contract on destination chain
    const targetContract = &#39;0x1234567890123456789012345678901234567890&#39;;
    const recipient = &#39;0x742d35Cc6634C0532925a3b8D4048b05fb2fE98c&#39;;
    const amount = ethers.utils.parseEther(&#39;5&#39;);

    // Encode function call for destination
    const iface = new ethers.utils.Interface([&#39;function deposit(address,uint256)&#39;]);
    const payload = iface.encodeFunctionData(&#39;deposit&#39;, [recipient, amount]);

    // Approve IU2U spending
    const iu2u = new ethers.Contract(await iu2u.getIU2UTokenAddress(), ERC20_ABI, signer);
    await iu2u.approve(iu2uGateway.address, amount);

    // Call contract with IU2U transfer
    const tx = await iu2uGateway.callContractWithToken(
      &#39;polygon&#39;, // destination chain
      targetContract,
      payload,
      &#39;IU2U&#39;,
      amount
    );

    console.log(&#39;Cross-chain contract call initiated:&#39;, tx.hash);

  } catch (error) {
    console.error(&#39;Cross-chain call failed:&#39;, error);
  }
}
</code></pre>
<h2>6. Error Handling</h2>
<p>Implement proper error handling for production applications:</p>
<pre><code class="language-javascript">async function robustSwap() {
  try {
    // Attempt swap
    const tx = await aggregator.executeSwap(swapParams);
    
    // Wait for confirmation
    const receipt = await tx.wait();
    
    if (receipt.status === 1) {
      console.log(&#39;Swap successful!&#39;);
    } else {
      throw new Error(&#39;Transaction failed&#39;);
    }
  } catch (error) {
    if (error.code === &#39;INSUFFICIENT_FUNDS&#39;) {
      console.error(&#39;Insufficient balance&#39;);
    } else if (error.code === &#39;USER_REJECTED&#39;) {
      console.error(&#39;User rejected transaction&#39;);
    } else if (error.message.includes(&#39;slippage&#39;)) {
      console.error(&#39;Slippage tolerance exceeded&#39;);
    } else {
      console.error(&#39;Unknown error:&#39;, error);
    }
  }
}
</code></pre>
<h2>5. Integration Examples</h2>
<h3>Combined Gasless + Cross-Chain dApp</h3>
<p>Build a complete dApp that combines both systems:</p>
<pre><code class="language-javascript">async function completeUserFlow() {
  try {
    // Step 1: Set up gas credits
    await setupGasCredits();

    // Step 2: Execute gasless staking
    await gaslessStake(ethers.utils.parseEther(&#39;1&#39;));

    // Step 3: Cross-chain IU2U transfer to claim rewards elsewhere
    await sendIU2UCrossChain();

    console.log(&#39;Complete user flow executed successfully!&#39;);

  } catch (error) {
    console.error(&#39;User flow failed:&#39;, error);
  }
}

// Gasless staking function
async function gaslessStake(amount) {
  const stakingContract = &#39;0x...&#39;; // Your staking contract
  const iface = new ethers.utils.Interface([&#39;function stake(uint256)&#39;]);
  const data = iface.encodeFunctionData(&#39;stake&#39;, [amount]);

  const metaTx = { to: stakingContract, value: 0, data };
  // ... execute via MetaTxGateway
}
</code></pre>
<h2>Next Steps</h2>
<p>Now that you&#39;ve completed the quick start:</p>
<ol>
<li><strong><a href="../core-concepts/protocol-overview.md">Explore Core Concepts</a></strong> - Understand the integrated IU2U system</li>
<li><strong><a href="../metatx/overview.md">Learn Gasless Meta Transactions</a></strong> - Deep dive into gasless transactions</li>
<li><strong><a href="../cross-chain/message-passing.md">Study Cross-Chain Operations</a></strong> - Master IU2U bridge functionality</li>
<li><strong><a href="../api-reference/iu2u-gateway.md">Read API Reference</a></strong> - Complete function documentation</li>
<li><strong><a href="../getting-started/configuration.md">Check Configuration</a></strong> - Set up both systems properly</li>
</ol>
<h2>Common Patterns</h2>
<h3>React Hook Example</h3>
<pre><code class="language-javascript">import { useState, useEffect } from &#39;react&#39;;
import { useIU2U } from &#39;@iu2u/react-hooks&#39;;

function SwapComponent() {
  const { iu2u, aggregator } = useIU2U();
  const [quote, setQuote] = useState(null);
  
  useEffect(() =&gt; {
    async function getQuote() {
      const result = await aggregator.getOptimalQuote(
        tokenIn,
        tokenOut,
        amountIn
      );
      setQuote(result);
    }
    
    getQuote();
  }, [tokenIn, tokenOut, amountIn]);
  
  return (
    &lt;div&gt;
      {quote &amp;&amp; (
        &lt;p&gt;Best rate: {quote.bestAmount} tokens&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}
</code></pre>
<h3>Vue.js Integration</h3>
<pre><code class="language-javascript">import { reactive, computed } from &#39;vue&#39;;
import { IU2UProvider } from &#39;@iu2u/sdk&#39;;

export default {
  setup() {
    const state = reactive({
      provider: null,
      quote: null
    });
    
    const initIU2U = async () =&gt; {
      state.provider = new IU2UProvider({
        network: &#39;mainnet&#39;
      });
    };
    
    return {
      state,
      initIU2U
    };
  }
};
</code></pre>
<h2>Support &amp; Community</h2>
<ul>
<li>üìñ <strong>Documentation</strong>: You&#39;re reading it!</li>
<li>üí¨ <strong>Discord</strong>: <a href="https://discord.gg/iu2u">Join our community</a></li>
<li>üêõ <strong>Issues</strong>: <a href="https://github.com/DINetworks/IU2U-Contracts/issues">GitHub Issues</a></li>
<li>üìß <strong>Email</strong>: <a href="mailto:support@iu2u.com">support@iu2u.com</a></li>
<li>üê¶ <strong>Twitter</strong>: <a href="https://twitter.com/IU2UProtocol">@IU2UProtocol</a></li>
</ul>
<p>Ready to dive deeper? Continue with the <a href="../core-concepts/protocol-overview.md">Core Concepts</a> section!</p>
<div class="page-break"></div><h1 id="installation">Installation</h1><p>This guide will help you set up the IU2U Protocol for development and integration.</p>
<h2>Prerequisites</h2>
<p>Before you begin, ensure you have the following installed:</p>
<ul>
<li><strong>Node.js</strong> (v16 or higher)</li>
<li><strong>npm</strong> or <strong>yarn</strong></li>
<li><strong>Git</strong></li>
<li><strong>Hardhat</strong> (for smart contract development)</li>
</ul>
<h2>Environment Setup</h2>
<h3>1. Clone the Repository</h3>
<pre><code class="language-bash">git clone https://github.com/DINetworks/DI-U2U-Contracts.git
cd DI-U2U-Contracts
</code></pre>
<h3>2. Install Dependencies</h3>
<pre><code class="language-bash">npm install
# or
yarn install
</code></pre>
<h3>3. Environment Configuration</h3>
<p>Create a <code>.env</code> file in the project root:</p>
<pre><code class="language-bash">cp .env.example .env
</code></pre>
<p>Configure your environment variables:</p>
<pre><code class="language-env"># Network RPC URLs
ETHEREUM_RPC_URL=https://mainnet.infura.io/v3/YOUR_PROJECT_ID
BSC_RPC_URL=https://bsc-dataseed1.binance.org/
POLYGON_RPC_URL=https://polygon-mainnet.infura.io/v3/YOUR_PROJECT_ID
AVALANCHE_RPC_URL=https://api.avax.network/ext/bc/C/rpc
ARBITRUM_RPC_URL=https://arb1.arbitrum.io/rpc
OPTIMISM_RPC_URL=https://mainnet.optimism.io
BASE_RPC_URL=https://mainnet.base.org

# Private Keys (for deployment)
DEPLOYER_PRIVATE_KEY=your_private_key_here
RELAYER_PRIVATE_KEY=your_relayer_private_key_here

# API Keys
ETHERSCAN_API_KEY=your_etherscan_api_key
BSCSCAN_API_KEY=your_bscscan_api_key
POLYGONSCAN_API_KEY=your_polygonscan_api_key

# IU2U Configuration
CROSSFI_CHAIN_ID=4157
IU2U_TOKEN_ADDRESS=0x...
</code></pre>
<h2>Package Installation</h2>
<h3>NPM Package</h3>
<p>Install the IU2U SDK for frontend integration:</p>
<pre><code class="language-bash">npm install @iu2u/sdk
# or
yarn add @iu2u/sdk
</code></pre>
<h3>Smart Contract Dependencies</h3>
<p>The contracts use OpenZeppelin and other standard libraries:</p>
<pre><code class="language-bash">npm install @openzeppelin/contracts
npm install @axelar-network/axelar-gmp-sdk-solidity
</code></pre>
<h2>Network Configuration</h2>
<h3>Supported Networks</h3>
<p>The IU2U Protocol is deployed on the following networks:</p>
<table>
<thead>
<tr>
<th>Network</th>
<th>Chain ID</th>
<th>RPC URL</th>
</tr>
</thead>
<tbody><tr>
<td>Ethereum</td>
<td>1</td>
<td><code>https://mainnet.infura.io/v3/YOUR_PROJECT_ID</code></td>
</tr>
<tr>
<td>BSC</td>
<td>56</td>
<td><code>https://bsc-dataseed1.binance.org/</code></td>
</tr>
<tr>
<td>Polygon</td>
<td>137</td>
<td><code>https://polygon-mainnet.infura.io/v3/YOUR_PROJECT_ID</code></td>
</tr>
<tr>
<td>Avalanche</td>
<td>43114</td>
<td><code>https://api.avax.network/ext/bc/C/rpc</code></td>
</tr>
<tr>
<td>Arbitrum</td>
<td>42161</td>
<td><code>https://arb1.arbitrum.io/rpc</code></td>
</tr>
<tr>
<td>Optimism</td>
<td>10</td>
<td><code>https://mainnet.optimism.io</code></td>
</tr>
<tr>
<td>Base</td>
<td>8453</td>
<td><code>https://mainnet.base.org</code></td>
</tr>
</tbody></table>
<h3>Hardhat Configuration</h3>
<p>Update your <code>hardhat.config.js</code>:</p>
<pre><code class="language-javascript">require(&#39;@nomiclabs/hardhat-ethers&#39;);
require(&#39;@nomiclabs/hardhat-etherscan&#39;);
require(&#39;hardhat-gas-reporter&#39;);
require(&#39;dotenv&#39;).config();

module.exports = {
  solidity: {
    version: &quot;0.8.24&quot;,
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      },
      viaIR: true
    }
  },
  networks: {
    ethereum: {
      url: process.env.ETHEREUM_RPC_URL,
      accounts: [process.env.DEPLOYER_PRIVATE_KEY],
      chainId: 1
    },
    bsc: {
      url: process.env.BSC_RPC_URL,
      accounts: [process.env.DEPLOYER_PRIVATE_KEY],
      chainId: 56
    },
    polygon: {
      url: process.env.POLYGON_RPC_URL,
      accounts: [process.env.DEPLOYER_PRIVATE_KEY],
      chainId: 137
    },
    // Add other networks...
  },
  etherscan: {
    apiKey: {
      mainnet: process.env.ETHERSCAN_API_KEY,
      bsc: process.env.BSCSCAN_API_KEY,
      polygon: process.env.POLYGONSCAN_API_KEY
    }
  }
};
</code></pre>
<h2>Verification</h2>
<h3>Test Installation</h3>
<p>Run the test suite to verify everything is working:</p>
<pre><code class="language-bash">npx hardhat test
</code></pre>
<h3>Compile Contracts</h3>
<p>Compile the smart contracts:</p>
<pre><code class="language-bash">npx hardhat compile
</code></pre>
<h3>Local Deployment</h3>
<p>Deploy to local Hardhat network:</p>
<pre><code class="language-bash">npx hardhat node
# In another terminal
npx hardhat run scripts/deploy-simple.js --network localhost
</code></pre>
<h2>IDE Setup</h2>
<h3>VS Code Extensions</h3>
<p>Recommended VS Code extensions:</p>
<ul>
<li><strong>Solidity</strong> by Juan Blanco</li>
<li><strong>Hardhat for Visual Studio Code</strong></li>
<li><strong>GitBook</strong> (for documentation editing)</li>
<li><strong>Prettier - Code formatter</strong></li>
<li><strong>ESLint</strong></li>
</ul>
<h3>VS Code Settings</h3>
<p>Add to your <code>settings.json</code>:</p>
<pre><code class="language-json">{
  &quot;solidity.defaultCompiler&quot;: &quot;localNodeModule&quot;,
  &quot;solidity.compileUsingRemoteVersion&quot;: &quot;v0.8.24+commit.a1b79de6&quot;,
  &quot;solidity.packageDefaultDependenciesContractsDirectory&quot;: &quot;contracts&quot;,
  &quot;solidity.packageDefaultDependenciesDirectory&quot;: &quot;node_modules&quot;
}
</code></pre>
<h2>Next Steps</h2>
<p>Now that you have IU2U installed, you can:</p>
<ol>
<li><strong><a href="quick-start.md">Follow the Quick Start Guide</a></strong> for basic usage</li>
<li><strong><a href="../core-concepts/protocol-overview.md">Learn Core Concepts</a></strong> to understand the protocol</li>
<li><strong><a href="../examples/basic-swap.md">Explore Examples</a></strong> for integration patterns</li>
</ol>
<h2>Troubleshooting</h2>
<h3>Common Issues</h3>
<p><strong>Node.js Version</strong></p>
<pre><code class="language-bash"># Check Node.js version
node --version
# Should be v16 or higher
</code></pre>
<p><strong>Dependencies</strong></p>
<pre><code class="language-bash"># Clear node_modules and reinstall
rm -rf node_modules package-lock.json
npm install
</code></pre>
<p><strong>Hardhat Compilation</strong></p>
<pre><code class="language-bash"># Clear Hardhat cache
npx hardhat clean
npx hardhat compile
</code></pre>
<h3>Getting Help</h3>
<p>If you encounter issues:</p>
<ol>
<li>Check the <a href="../resources/troubleshooting.md">Troubleshooting Guide</a></li>
<li>Search existing <a href="https://github.com/DINetworks/IU2U-Contracts/issues">GitHub Issues</a></li>
<li>Join our <a href="https://discord.gg/iu2u">Discord community</a></li>
<li>Create a new issue with detailed information</li>
</ol>
<div class="page-break"></div><h1 id="integration-guide">Integration Guide</h1><p>Welcome to the IU2U Protocol integration documentation. This section provides comprehensive guides for integrating IU2U&#39;s cross-chain infrastructure into your applications, wallets, exchanges, and dApps.</p>
<h2>Quick Start Guide</h2>
<h3>Prerequisites</h3>
<p>Before integrating with IU2U Protocol, ensure you have:</p>
<ol>
<li><strong>Node.js Environment</strong> (v16 or later)</li>
<li><strong>Web3 Library</strong> (ethers.js v5+ or web3.js)</li>
<li><strong>Smart Contract ABIs</strong> (provided in artifacts/)</li>
<li><strong>API Keys</strong> for supported blockchains</li>
<li><strong>Basic Understanding</strong> of cross-chain operations</li>
</ol>
<h3>Installation</h3>
<pre><code class="language-bash"># Install required dependencies
npm install ethers @iu2u/sdk axios

# For React applications
npm install @iu2u/react-hooks

# For advanced features
npm install @iu2u/multicall @iu2u/gas-oracle
</code></pre>
<h3>Basic Setup</h3>
<pre><code class="language-javascript">import { ethers } from &#39;ethers&#39;;
import { IU2UGateway, CrossChainAggregator } from &#39;@iu2u/sdk&#39;;

// Initialize providers for supported chains
const providers = {
    ethereum: new ethers.JsonRpcProvider(process.env.ETHEREUM_RPC),
    polygon: new ethers.JsonRpcProvider(process.env.POLYGON_RPC),
    bsc: new ethers.JsonRpcProvider(process.env.BSC_RPC),
    avalanche: new ethers.JsonRpcProvider(process.env.AVALANCHE_RPC)
};

// Initialize IU2U Gateway
const gateway = new IU2UGateway({
    providers,
    defaultChain: &#39;ethereum&#39;,
    relayerEndpoint: &#39;https://relayer.iu2u.com&#39;
});

// Initialize Cross-Chain Aggregator
const aggregator = new CrossChainAggregator({
    gateway,
    supportedDEXs: [&#39;uniswap&#39;, &#39;sushiswap&#39;, &#39;pancakeswap&#39;]
});
</code></pre>
<h2>Integration Types</h2>
<h3>1. Wallet Integration</h3>
<p>Perfect for wallet providers wanting to offer cross-chain functionality.</p>
<h4>Features Included:</h4>
<ul>
<li>Cross-chain token transfers</li>
<li>Multi-chain balance aggregation</li>
<li>Gasless transactions</li>
<li>DEX aggregation</li>
</ul>
<h4>Sample Implementation:</h4>
<pre><code class="language-javascript">class IU2UWalletIntegration {
    constructor(walletProvider) {
        this.wallet = walletProvider;
        this.gateway = new IU2UGateway({
            signer: walletProvider.getSigner()
        });
    }

    async getMultiChainBalance(userAddress) {
        const chains = [&#39;ethereum&#39;, &#39;polygon&#39;, &#39;bsc&#39;, &#39;avalanche&#39;];
        const balances = {};

        for (const chain of chains) {
            try {
                const balance = await this.gateway.getBalance(userAddress, chain);
                balances[chain] = {
                    native: balance.native,
                    iu2u: balance.iu2u,
                    tokens: balance.tokens
                };
            } catch (error) {
                console.error(`Failed to get balance for ${chain}:`, error);
                balances[chain] = null;
            }
        }

        return balances;
    }

    async transferCrossChain(params) {
        const {
            fromChain,
            toChain,
            token,
            amount,
            recipientAddress,
            gasless = false
        } = params;

        try {
            if (gasless) {
                return await this.gateway.transferWithGasCredits({
                    fromChain,
                    toChain,
                    token,
                    amount,
                    recipient: recipientAddress
                });
            } else {
                return await this.gateway.transfer({
                    fromChain,
                    toChain,
                    token,
                    amount,
                    recipient: recipientAddress
                });
            }
        } catch (error) {
            throw new Error(`Cross-chain transfer failed: ${error.message}`);
        }
    }

    async swapAndBridge(params) {
        const {
            fromChain,
            toChain,
            fromToken,
            toToken,
            amountIn,
            recipientAddress,
            slippageTolerance = 0.5
        } = params;

        // Get optimal route
        const route = await this.gateway.getOptimalRoute({
            fromChain,
            toChain,
            fromToken,
            toToken,
            amountIn,
            slippageTolerance
        });

        // Execute swap and bridge
        return await this.gateway.executeRoute({
            route,
            recipient: recipientAddress
        });
    }
}

// Usage in wallet
const iu2uIntegration = new IU2UWalletIntegration(walletProvider);

// Get user balances across all chains
const balances = await iu2uIntegration.getMultiChainBalance(userAddress);

// Transfer tokens cross-chain
const transfer = await iu2uIntegration.transferCrossChain({
    fromChain: &#39;ethereum&#39;,
    toChain: &#39;polygon&#39;,
    token: &#39;USDC&#39;,
    amount: ethers.parseUnits(&#39;100&#39;, 6),
    recipientAddress: &#39;0x...&#39;,
    gasless: true
});
</code></pre>
<h3>2. Exchange Integration</h3>
<p>For centralized and decentralized exchanges wanting to offer cross-chain trading.</p>
<h4>Features Included:</h4>
<ul>
<li>Cross-chain order routing</li>
<li>Liquidity aggregation</li>
<li>Automated market making</li>
<li>Risk management</li>
</ul>
<h4>Sample Implementation:</h4>
<pre><code class="language-javascript">class IU2UExchangeIntegration {
    constructor(exchangeConfig) {
        this.config = exchangeConfig;
        this.gateway = new IU2UGateway(exchangeConfig.gateway);
        this.aggregator = new CrossChainAggregator(exchangeConfig.aggregator);
        this.orderBook = new Map();
    }

    async createCrossChainOrder(order) {
        const {
            trader,
            fromChain,
            toChain,
            fromToken,
            toToken,
            amountIn,
            minAmountOut,
            deadline
        } = order;

        // Validate order
        await this.validateOrder(order);

        // Get best execution route
        const route = await this.aggregator.getBestRoute({
            fromChain,
            toChain,
            fromToken,
            toToken,
            amountIn
        });

        if (route.outputAmount &lt; minAmountOut) {
            throw new Error(&#39;Insufficient output amount&#39;);
        }

        // Create order in system
        const orderId = this.generateOrderId();
        this.orderBook.set(orderId, {
            ...order,
            route,
            status: &#39;pending&#39;,
            createdAt: Date.now()
        });

        return {
            orderId,
            route,
            estimatedOutput: route.outputAmount,
            estimatedTime: route.estimatedTime,
            fees: route.fees
        };
    }

    async executeOrder(orderId) {
        const order = this.orderBook.get(orderId);
        if (!order) {
            throw new Error(&#39;Order not found&#39;);
        }

        try {
            // Update order status
            order.status = &#39;executing&#39;;
            this.orderBook.set(orderId, order);

            // Execute the cross-chain route
            const result = await this.aggregator.executeRoute(order.route);

            // Update order with results
            order.status = &#39;completed&#39;;
            order.executionHash = result.transactionHash;
            order.actualOutput = result.outputAmount;
            order.completedAt = Date.now();
            
            this.orderBook.set(orderId, order);

            return result;
        } catch (error) {
            order.status = &#39;failed&#39;;
            order.error = error.message;
            order.failedAt = Date.now();
            this.orderBook.set(orderId, order);
            
            throw error;
        }
    }

    async getOrderStatus(orderId) {
        const order = this.orderBook.get(orderId);
        if (!order) {
            throw new Error(&#39;Order not found&#39;);
        }

        // If order is executing, check cross-chain status
        if (order.status === &#39;executing&#39; &amp;&amp; order.executionHash) {
            const status = await this.gateway.getTransactionStatus(order.executionHash);
            
            if (status.completed) {
                order.status = &#39;completed&#39;;
                order.actualOutput = status.outputAmount;
                order.completedAt = Date.now();
                this.orderBook.set(orderId, order);
            }
        }

        return {
            orderId,
            status: order.status,
            createdAt: order.createdAt,
            completedAt: order.completedAt,
            route: order.route,
            actualOutput: order.actualOutput,
            error: order.error
        };
    }

    async validateOrder(order) {
        // Check if chains are supported
        const supportedChains = await this.gateway.getSupportedChains();
        if (!supportedChains.includes(order.fromChain) || !supportedChains.includes(order.toChain)) {
            throw new Error(&#39;Unsupported chain&#39;);
        }

        // Check token support
        const supportedTokens = await this.gateway.getSupportedTokens(order.fromChain);
        if (!supportedTokens.includes(order.fromToken)) {
            throw new Error(&#39;Unsupported token&#39;);
        }

        // Check deadline
        if (order.deadline &amp;&amp; order.deadline &lt; Date.now()) {
            throw new Error(&#39;Order deadline passed&#39;);
        }

        return true;
    }

    generateOrderId() {
        return `iu2u_order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// Usage in exchange
const exchange = new IU2UExchangeIntegration({
    gateway: { /* gateway config */ },
    aggregator: { /* aggregator config */ }
});

// Create cross-chain order
const order = await exchange.createCrossChainOrder({
    trader: &#39;0x...&#39;,
    fromChain: &#39;ethereum&#39;,
    toChain: &#39;bsc&#39;,
    fromToken: &#39;USDC&#39;,
    toToken: &#39;USDT&#39;,
    amountIn: ethers.parseUnits(&#39;1000&#39;, 6),
    minAmountOut: ethers.parseUnits(&#39;995&#39;, 18),
    deadline: Date.now() + (30 * 60 * 1000) // 30 minutes
});

// Execute order
const result = await exchange.executeOrder(order.orderId);
</code></pre>
<h3>3. DeFi Protocol Integration</h3>
<p>For DeFi protocols wanting to expand to multiple chains.</p>
<h4>Features Included:</h4>
<ul>
<li>Cross-chain yield farming</li>
<li>Multi-chain governance</li>
<li>Liquidity migration</li>
<li>Risk distribution</li>
</ul>
<h4>Sample Implementation:</h4>
<pre><code class="language-javascript">class IU2UDeFiIntegration {
    constructor(protocolConfig) {
        this.config = protocolConfig;
        this.gateway = new IU2UGateway(protocolConfig.gateway);
        this.multicall = new MulticallLibrary(protocolConfig.multicall);
        this.positions = new Map();
    }

    async deployToNewChain(chainName, deploymentConfig) {
        const {
            governanceToken,
            stakingContract,
            liquidityPools,
            initialParams
        } = deploymentConfig;

        try {
            // Deploy governance token on new chain
            const tokenDeployment = await this.gateway.deployContract({
                chain: chainName,
                contractName: &#39;GovernanceToken&#39;,
                constructorArgs: [
                    governanceToken.name,
                    governanceToken.symbol,
                    governanceToken.initialSupply
                ]
            });

            // Deploy staking contract
            const stakingDeployment = await this.gateway.deployContract({
                chain: chainName,
                contractName: &#39;StakingContract&#39;,
                constructorArgs: [
                    tokenDeployment.address,
                    initialParams.stakingRewards
                ]
            });

            // Set up liquidity pools
            const poolDeployments = [];
            for (const pool of liquidityPools) {
                const poolDeployment = await this.gateway.deployContract({
                    chain: chainName,
                    contractName: &#39;LiquidityPool&#39;,
                    constructorArgs: [
                        pool.tokenA,
                        pool.tokenB,
                        pool.fee
                    ]
                });
                poolDeployments.push(poolDeployment);
            }

            // Register new chain in protocol
            await this.registerNewChain({
                chainName,
                contracts: {
                    governanceToken: tokenDeployment.address,
                    stakingContract: stakingDeployment.address,
                    liquidityPools: poolDeployments.map(p =&gt; p.address)
                }
            });

            return {
                chainName,
                deployments: {
                    governanceToken: tokenDeployment,
                    stakingContract: stakingDeployment,
                    liquidityPools: poolDeployments
                }
            };

        } catch (error) {
            throw new Error(`Deployment to ${chainName} failed: ${error.message}`);
        }
    }

    async migrateLiquidity(migrationParams) {
        const {
            fromChain,
            toChain,
            poolAddress,
            amount,
            userAddress
        } = migrationParams;

        // Get user&#39;s liquidity position
        const position = await this.getUserPosition(fromChain, poolAddress, userAddress);
        
        if (position.amount &lt; amount) {
            throw new Error(&#39;Insufficient liquidity position&#39;);
        }

        try {
            // Remove liquidity from source chain
            const removeTx = await this.gateway.callContract({
                chain: fromChain,
                contract: poolAddress,
                method: &#39;removeLiquidity&#39;,
                args: [amount, userAddress]
            });

            // Wait for removal confirmation
            await this.gateway.waitForTransaction(removeTx.hash);

            // Add liquidity to destination chain
            const addTx = await this.gateway.callContract({
                chain: toChain,
                contract: this.getPoolAddress(toChain, poolAddress),
                method: &#39;addLiquidity&#39;,
                args: [amount, userAddress]
            });

            // Update position tracking
            await this.updateUserPosition({
                userAddress,
                fromChain,
                toChain,
                poolAddress,
                amount
            });

            return {
                removeTx: removeTx.hash,
                addTx: addTx.hash,
                migratedAmount: amount
            };

        } catch (error) {
            throw new Error(`Liquidity migration failed: ${error.message}`);
        }
    }

    async getCrossChainYield(userAddress) {
        const supportedChains = await this.gateway.getSupportedChains();
        const yieldData = {};

        // Get yield data from all chains in parallel
        const yieldPromises = supportedChains.map(async (chain) =&gt; {
            try {
                const chainYield = await this.getChainYield(chain, userAddress);
                return { chain, yield: chainYield };
            } catch (error) {
                console.error(`Failed to get yield for ${chain}:`, error);
                return { chain, yield: null };
            }
        });

        const results = await Promise.all(yieldPromises);
        
        results.forEach(({ chain, yield: yieldInfo }) =&gt; {
            yieldData[chain] = yieldInfo;
        });

        return {
            totalYield: this.calculateTotalYield(yieldData),
            chainBreakdown: yieldData,
            recommendations: this.getYieldOptimizationRecommendations(yieldData)
        };
    }

    async executeMultiChainGovernance(proposal) {
        const {
            proposalId,
            targetChains,
            actions,
            executionDelay
        } = proposal;

        // Validate proposal across all target chains
        for (const chain of targetChains) {
            await this.validateGovernanceAction(chain, actions[chain]);
        }

        // Execute actions on all chains
        const executionResults = {};
        
        for (const chain of targetChains) {
            try {
                const result = await this.executeGovernanceAction(chain, actions[chain]);
                executionResults[chain] = {
                    success: true,
                    transactionHash: result.hash,
                    executedAt: Date.now()
                };
            } catch (error) {
                executionResults[chain] = {
                    success: false,
                    error: error.message,
                    failedAt: Date.now()
                };
            }
        }

        return {
            proposalId,
            executionResults,
            overallSuccess: Object.values(executionResults).every(r =&gt; r.success)
        };
    }

    async getChainYield(chain, userAddress) {
        const contracts = this.config.chainContracts[chain];
        
        // Use multicall for efficient data fetching
        const calls = [
            {
                target: contracts.stakingContract,
                callData: this.encodeCall(&#39;getStakingRewards&#39;, [userAddress])
            },
            {
                target: contracts.liquidityPool,
                callData: this.encodeCall(&#39;getLiquidityRewards&#39;, [userAddress])
            },
            {
                target: contracts.farmingContract,
                callData: this.encodeCall(&#39;getFarmingRewards&#39;, [userAddress])
            }
        ];

        const results = await this.multicall.aggregate(chain, calls);
        
        return {
            stakingRewards: this.decodeResult(results[0]),
            liquidityRewards: this.decodeResult(results[1]),
            farmingRewards: this.decodeResult(results[2]),
            totalRewards: this.calculateTotalRewards(results)
        };
    }

    calculateTotalYield(yieldData) {
        let total = 0;
        
        Object.values(yieldData).forEach(chainYield =&gt; {
            if (chainYield &amp;&amp; chainYield.totalRewards) {
                total += parseFloat(ethers.formatEther(chainYield.totalRewards));
            }
        });

        return total;
    }

    getYieldOptimizationRecommendations(yieldData) {
        const recommendations = [];
        
        // Find best yielding chains
        const sortedChains = Object.entries(yieldData)
            .filter(([, data]) =&gt; data &amp;&amp; data.totalRewards)
            .sort(([, a], [, b]) =&gt; b.totalRewards - a.totalRewards);

        if (sortedChains.length &gt; 1) {
            const [bestChain, bestYield] = sortedChains[0];
            const [worstChain, worstYield] = sortedChains[sortedChains.length - 1];
            
            if (bestYield.totalRewards &gt; worstYield.totalRewards * 1.2) {
                recommendations.push({
                    type: &#39;migrate&#39;,
                    from: worstChain,
                    to: bestChain,
                    expectedIncrease: bestYield.totalRewards - worstYield.totalRewards,
                    reason: &#39;Higher yield available&#39;
                });
            }
        }

        return recommendations;
    }
}

// Usage in DeFi protocol
const defiProtocol = new IU2UDeFiIntegration({
    gateway: { /* gateway config */ },
    multicall: { /* multicall config */ },
    chainContracts: { /* contract addresses per chain */ }
});

// Deploy to new chain
const deployment = await defiProtocol.deployToNewChain(&#39;arbitrum&#39;, {
    governanceToken: {
        name: &#39;Protocol Token&#39;,
        symbol: &#39;PROTO&#39;,
        initialSupply: ethers.parseEther(&#39;1000000&#39;)
    },
    stakingContract: {},
    liquidityPools: [
        { tokenA: &#39;USDC&#39;, tokenB: &#39;PROTO&#39;, fee: 3000 }
    ],
    initialParams: {
        stakingRewards: ethers.parseEther(&#39;100&#39;)
    }
});

// Get cross-chain yield for user
const yieldData = await defiProtocol.getCrossChainYield(&#39;0x...&#39;);
</code></pre>
<h3>4. Mobile App Integration</h3>
<p>For mobile applications requiring cross-chain functionality.</p>
<h4>Features Included:</h4>
<ul>
<li>Mobile-optimized SDK</li>
<li>Offline transaction caching</li>
<li>Push notifications</li>
<li>Simplified UX patterns</li>
</ul>
<h4>Sample Implementation:</h4>
<pre><code class="language-javascript">// React Native integration
import { IU2UMobileSDK } from &#39;@iu2u/mobile-sdk&#39;;
import AsyncStorage from &#39;@react-native-async-storage/async-storage&#39;;
import PushNotification from &#39;react-native-push-notification&#39;;

class IU2UMobileIntegration {
    constructor() {
        this.sdk = new IU2UMobileSDK({
            storage: AsyncStorage,
            notifications: PushNotification
        });
        
        this.initializeNotifications();
    }

    async initialize(walletPrivateKey) {
        try {
            await this.sdk.initialize({
                privateKey: walletPrivateKey,
                enableOfflineMode: true,
                enableNotifications: true
            });

            // Set up event listeners
            this.sdk.on(&#39;transactionComplete&#39;, this.handleTransactionComplete.bind(this));
            this.sdk.on(&#39;crossChainConfirmed&#39;, this.handleCrossChainConfirmed.bind(this));
            this.sdk.on(&#39;error&#39;, this.handleError.bind(this));

            return true;
        } catch (error) {
            console.error(&#39;Failed to initialize IU2U SDK:&#39;, error);
            return false;
        }
    }

    async quickSwap(params) {
        const {
            fromToken,
            toToken,
            amount,
            fromChain,
            toChain
        } = params;

        try {
            // Show loading state
            this.showLoading(&#39;Finding best route...&#39;);

            // Get optimal route
            const route = await this.sdk.getOptimalRoute({
                fromToken,
                toToken,
                amount,
                fromChain,
                toChain
            });

            // Show route confirmation
            const confirmed = await this.showRouteConfirmation(route);
            if (!confirmed) return null;

            // Execute swap
            this.updateLoading(&#39;Executing swap...&#39;);
            const result = await this.sdk.executeSwap(route);

            // Cache transaction for offline viewing
            await this.cacheTransaction(result);

            this.hideLoading();
            this.showSuccess(&#39;Swap initiated successfully!&#39;);

            return result;

        } catch (error) {
            this.hideLoading();
            this.showError(`Swap failed: ${error.message}`);
            throw error;
        }
    }

    async getPortfolio() {
        try {
            // Try to get cached data first
            const cachedPortfolio = await this.getCachedPortfolio();
            
            // Return cached data immediately for better UX
            if (cachedPortfolio) {
                // Fetch fresh data in background
                this.refreshPortfolioInBackground();
                return cachedPortfolio;
            }

            // Fetch fresh data if no cache
            const portfolio = await this.sdk.getMultiChainPortfolio();
            await this.cachePortfolio(portfolio);
            
            return portfolio;

        } catch (error) {
            console.error(&#39;Failed to get portfolio:&#39;, error);
            
            // Return cached data as fallback
            return await this.getCachedPortfolio() || {
                totalValue: 0,
                chains: {},
                lastUpdated: null
            };
        }
    }

    async enableNotifications() {
        try {
            const permission = await PushNotification.requestPermissions();
            if (permission.alert) {
                await this.sdk.subscribeToNotifications({
                    transactionUpdates: true,
                    priceAlerts: true,
                    crossChainConfirmations: true
                });
                return true;
            }
            return false;
        } catch (error) {
            console.error(&#39;Failed to enable notifications:&#39;, error);
            return false;
        }
    }

    initializeNotifications() {
        PushNotification.configure({
            onNotification: (notification) =&gt; {
                if (notification.userInteraction) {
                    // User tapped notification
                    this.handleNotificationTap(notification);
                }
            }
        });
    }

    handleTransactionComplete(transaction) {
        PushNotification.localNotification({
            title: &#39;Transaction Complete&#39;,
            message: `Your ${transaction.type} transaction has been confirmed`,
            data: { transactionId: transaction.id }
        });
    }

    handleCrossChainConfirmed(confirmation) {
        PushNotification.localNotification({
            title: &#39;Cross-Chain Transfer Complete&#39;,
            message: `Your tokens have arrived on ${confirmation.destinationChain}`,
            data: { confirmationId: confirmation.id }
        });
    }

    handleError(error) {
        if (error.severity === &#39;high&#39;) {
            PushNotification.localNotification({
                title: &#39;Transaction Failed&#39;,
                message: error.message,
                data: { errorId: error.id }
            });
        }
    }

    async cacheTransaction(transaction) {
        const cached = await AsyncStorage.getItem(&#39;iu2u_transactions&#39;) || &#39;[]&#39;;
        const transactions = JSON.parse(cached);
        
        transactions.unshift({
            ...transaction,
            cachedAt: Date.now()
        });

        // Keep only last 50 transactions
        const trimmed = transactions.slice(0, 50);
        
        await AsyncStorage.setItem(&#39;iu2u_transactions&#39;, JSON.stringify(trimmed));
    }

    async getCachedPortfolio() {
        try {
            const cached = await AsyncStorage.getItem(&#39;iu2u_portfolio&#39;);
            if (cached) {
                const portfolio = JSON.parse(cached);
                
                // Check if cache is still fresh (5 minutes)
                const isFresh = Date.now() - portfolio.cachedAt &lt; 5 * 60 * 1000;
                if (isFresh) {
                    return portfolio.data;
                }
            }
            return null;
        } catch (error) {
            console.error(&#39;Failed to get cached portfolio:&#39;, error);
            return null;
        }
    }

    async cachePortfolio(portfolio) {
        try {
            const cacheData = {
                data: portfolio,
                cachedAt: Date.now()
            };
            
            await AsyncStorage.setItem(&#39;iu2u_portfolio&#39;, JSON.stringify(cacheData));
        } catch (error) {
            console.error(&#39;Failed to cache portfolio:&#39;, error);
        }
    }

    async refreshPortfolioInBackground() {
        try {
            const portfolio = await this.sdk.getMultiChainPortfolio();
            await this.cachePortfolio(portfolio);
            
            // Emit event for UI to refresh
            this.sdk.emit(&#39;portfolioUpdated&#39;, portfolio);
        } catch (error) {
            console.error(&#39;Background portfolio refresh failed:&#39;, error);
        }
    }

    // UI helper methods
    showLoading(message) {
        // Implement loading UI
        console.log(&#39;Loading:&#39;, message);
    }

    updateLoading(message) {
        // Update loading message
        console.log(&#39;Loading update:&#39;, message);
    }

    hideLoading() {
        // Hide loading UI
        console.log(&#39;Loading complete&#39;);
    }

    showSuccess(message) {
        // Show success message
        console.log(&#39;Success:&#39;, message);
    }

    showError(message) {
        // Show error message
        console.log(&#39;Error:&#39;, message);
    }

    async showRouteConfirmation(route) {
        // Show route confirmation dialog
        return new Promise((resolve) =&gt; {
            // Implement confirmation UI
            resolve(true); // User confirmed
        });
    }

    handleNotificationTap(notification) {
        // Handle notification tap - navigate to relevant screen
        const { data } = notification;
        
        if (data.transactionId) {
            // Navigate to transaction details
            console.log(&#39;Navigate to transaction:&#39;, data.transactionId);
        } else if (data.confirmationId) {
            // Navigate to confirmation details
            console.log(&#39;Navigate to confirmation:&#39;, data.confirmationId);
        }
    }
}

// Usage in React Native app
const iu2uMobile = new IU2UMobileIntegration();

// Initialize with user&#39;s wallet
await iu2uMobile.initialize(userPrivateKey);

// Enable notifications
await iu2uMobile.enableNotifications();

// Quick swap functionality
const swapResult = await iu2uMobile.quickSwap({
    fromToken: &#39;USDC&#39;,
    toToken: &#39;USDT&#39;,
    amount: ethers.parseUnits(&#39;100&#39;, 6),
    fromChain: &#39;ethereum&#39;,
    toChain: &#39;polygon&#39;
});

// Get user portfolio
const portfolio = await iu2uMobile.getPortfolio();
</code></pre>
<h2>Next Steps</h2>
<ol>
<li><strong>Choose Your Integration Type</strong>: Select the integration guide that best fits your use case</li>
<li><strong>Set Up Development Environment</strong>: Install required dependencies and tools</li>
<li><strong>Get API Access</strong>: Register for IU2U Protocol API access and obtain necessary keys</li>
<li><strong>Start with Basic Examples</strong>: Begin with simple cross-chain transfers before moving to complex integrations</li>
<li><strong>Test on Testnets</strong>: Use testnet environments for development and testing</li>
<li><strong>Deploy to Production</strong>: Follow our deployment guide for production release</li>
</ol>
<h2>Support Resources</h2>
<ul>
<li><strong>Technical Documentation</strong>: <a href="../api-reference/">API Reference</a></li>
<li><strong>Code Examples</strong>: <a href="../examples/">Integration Examples</a></li>
<li><strong>Developer Support</strong>: <a href="https://discord.gg/iu2u">Discord Community</a></li>
<li><strong>Bug Reports</strong>: <a href="https://github.com/iu2u/contracts/issues">GitHub Issues</a></li>
<li><strong>Feature Requests</strong>: <a href="https://forms.iu2u.com/features">Feature Request Form</a></li>
</ul>
<h2>Advanced Topics</h2>
<ul>
<li><a href="custom-relayer.md">Custom Relayer Setup</a></li>
<li><a href="gas-optimization.md">Gas Optimization Strategies</a></li>
<li><a href="security-practices.md">Security Best Practices</a></li>
<li><a href="monitoring.md">Monitoring and Analytics</a></li>
<li><a href="troubleshooting.md">Troubleshooting Guide</a></li>
</ul>

        </body>
        </html>
        